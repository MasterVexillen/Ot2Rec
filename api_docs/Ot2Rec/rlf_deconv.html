<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Ot2Rec.rlf_deconv API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Ot2Rec.rlf_deconv</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 Rosalind Franklin Institute
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the License for the specific
# language governing permissions and limitations under the License.


from glob import glob
import os
import numpy as np
from icecream import ic
from tqdm import tqdm
import pandas as pd
import yaml

import mrcfile
import tifffile

import RedLionfishDeconv as rlf

from . import user_args as uaMod
from . import magicgui as mgMod
from . import logger as logMod


itick = 0
def tickCallBack():
    global itick
    itick += 1


class RLF_deconv():
    &#34;&#34;&#34;
    Class encapsulating an RLF_deconv object
    &#34;&#34;&#34;
    def __init__(self, rootname, suffix, raw_folder, kernel_folder, out_folder, params_dict, orig_mrc, kernel_mrc):
        &#34;&#34;&#34;
        Initialise the RLF_deconv object

        Args:
            rootname (str): rootname of project
            orig_folder (ndarray): parent folder containing original images to be deconvolved
            kernel_folder (ndarray): parent folder containing kernel with which the image is to be deconvolved
            out_folder (ndarray): output parent folder for deconvolved tomograms
            params_dict (dict): dictionary containing all parameters used in RLF
            orig_mrc (bool): whether the original image is in MRC format (TIFF if false)
            kernel_mrc (bool): whether the kernel is in MRC format (TIFF if false)
        &#34;&#34;&#34;
        self.rootname = rootname
        self.suffix = suffix
        self.raw_folder = raw_folder
        self.kernel_folder = kernel_folder
        self.out_folder = out_folder
        self.params = params_dict
        self.orig_mrc = orig_mrc
        self.kernel_mrc = kernel_mrc

        # Initiating variables for later use
        self.orig = None
        self.kernel = None

        self._get_internal_metadata()


    def __call__(self):
        &#34;&#34;&#34;
        Method to start deconvolution
        &#34;&#34;&#34;
        self.out_files = []
        tqdm_iter = tqdm(range(len(self.plist)), ncols=100)

        for idx in tqdm_iter:
            self.orig_path = self.raw_files[idx]
            self.kernel_path = self.psf_files[idx]
            self.out_path = f&#34;{self.out_folder}/{self.plist[idx]}/{self.plist[idx]}_deconv.mrc&#34;

            # Read in raw image and kernel files
            if self.orig_mrc:
                self.orig = self.read_mrc(self.orig_path)
            else:
                self.orig = self.read_tiff(self.orig_path)

            self.orig = 256 * (self.orig-np.min(self.orig)) / np.ptp(self.orig)

            if self.kernel_mrc:
                self.kernel = np.flip(self.read_mrc(self.kernel_path))
            else:
                self.kernel = np.flip(self.read_tiff(self.kernel_path))

            # Deconvolve image
            out = self._deconv_array()

            # Save results
            with mrcfile.new(self.out_path, overwrite=True) as f:
                f.set_data(out)

            # Update output list
            self.out_files.append(self.out_path)

        # Update and export output metadata
        self.meta_out.outputs = self.out_files

        yaml_file = self.rootname + &#39;_rlf_deconv_mdout.yaml&#39;
        with open(yaml_file, &#39;w&#39;) as f:
            yaml.dump(self.meta_out.to_dict(), f, indent=4, sort_keys=False)



    @staticmethod
    def read_mrc(path):
        &#34;&#34;&#34;
        Method to read an MRC file and return a numpy array

        Returns:
            ndarray
        &#34;&#34;&#34;
        with mrcfile.open(path) as image:
            data = image.data

        return data


    @staticmethod
    def read_tiff(path):
        &#34;&#34;&#34;
        Method to read a TIFF file and return a numpy array

        Returns:
            ndarray
        &#34;&#34;&#34;
        data = tifffile.imread(path)

        return data


    def _deconv_array(self):
        &#34;&#34;&#34;
        Method to use RLF to deconvolve image
        &#34;&#34;&#34;

        image_deconvolved = rlf.doRLDeconvolutionFromNpArrays(
            self.orig, self.kernel,
            niter=self.params[&#39;niter&#39;],
            method=self.params[&#39;method&#39;].lower(),
            useBlockAlgorithm=self.params[&#39;useBlockAlgorithm&#39;],
            callbkTickFunc=tickCallBack(), # if self.params[&#39;callbkTickFunc&#39;] else None,
            resAsUint8=self.params[&#39;resAsUint8&#39;]
        )

        return image_deconvolved


    def _get_internal_metadata(self):
        &#34;&#34;&#34;
        Method to prepare internal metadata for processing and checking
        &#34;&#34;&#34;
        # Get process list
        raw_subfolders = (f&#34;{self.raw_folder}/&#34;
                          f&#34;{self.rootname}_*{self.suffix}&#34;)
        psf_subfolders = (f&#34;{self.kernel_folder}/&#34;
                          f&#34;{self.rootname}_*{self.suffix}&#34;)
        raw_set = set([i.split(&#34;/&#34;)[-1] for i in glob(raw_subfolders)])
        psf_set = set([i.split(&#34;/&#34;)[-1] for i in glob(psf_subfolders)])
        self.plist = sorted(list(raw_set &amp; psf_set))

        self.raw_files = []
        self.psf_files = []
        for proc in self.plist:
            # Create the folders and dictionary for future reference
            out_subfolders = f&#34;{self.out_folder}/{proc}&#34;
            os.makedirs(out_subfolders, exist_ok=True)

            # Find relevant files
            search = f&#34;{self.raw_folder}/{proc}/*_rec.mrc&#34;
            exclude = f&#34;{self.raw_folder}/{proc}/*_full_rec.mrc&#34;
            file_clean = list(set(glob(search))-set(glob(exclude)))[0]

            self.raw_files.append(file_clean)
            self.psf_files.append(glob(f&#34;{self.kernel_folder}/{proc}/*_PSF.mrc&#34;)[0])

        assert(len(self.raw_files)==len(self.psf_files)), \
            &#34;ERROR: lengths of raw and PSF file list not equal. File missing?&#34;

        self.meta_out = pd.DataFrame(columns=[&#39;raw_files&#39;, &#39;psf_files&#39;, &#39;outputs&#39;])
        self.meta_out.raw_files = self.raw_files
        self.meta_out.psf_files = self.psf_files


&#34;&#34;&#34;
PLUGIN METHODS
&#34;&#34;&#34;
def run():
    &#34;&#34;&#34;
    Method to deconvolve image using a given kernel (point-spread function)
    &#34;&#34;&#34;
    logger = logMod.Logger(log_path=&#34;o2r_rlf_deconv.log&#34;)

    # Parse user inputs
    args = mgMod.get_args_rldeconv.show(run=True)

    # Define deconvolution parameters and object
    deconv_params = dict({
        &#39;method&#39;: args.device.value,
        &#39;niter&#39;: args.niter.value,
        &#39;useBlockAlgorithm&#39;: args.block.value,
        &#39;callbkTickFunc&#39;: True,
        &#39;resAsUint8&#39;: args.uint.value,
    })

    logger(level=&#34;info&#34;,
           message=&#34;Ot2Rec-RLFDeconv started.&#34;)

    my_deconv = RLF_deconv(
        rootname = args.project_name.value,
        suffix = args.file_suffix.value,
        raw_folder=str(args.raw_folder.value),
        kernel_folder=str(args.psf_folder.value),
        out_folder=str(args.output_folder.value),
        params_dict=deconv_params,
        orig_mrc=args.image_type.value == &#39;mrc&#39;,
        kernel_mrc=args.psf_type.value == &#39;mrc&#39;
    )

    deconvd_image = my_deconv()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Ot2Rec.rlf_deconv.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to deconvolve image using a given kernel (point-spread function)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run():
    &#34;&#34;&#34;
    Method to deconvolve image using a given kernel (point-spread function)
    &#34;&#34;&#34;
    logger = logMod.Logger(log_path=&#34;o2r_rlf_deconv.log&#34;)

    # Parse user inputs
    args = mgMod.get_args_rldeconv.show(run=True)

    # Define deconvolution parameters and object
    deconv_params = dict({
        &#39;method&#39;: args.device.value,
        &#39;niter&#39;: args.niter.value,
        &#39;useBlockAlgorithm&#39;: args.block.value,
        &#39;callbkTickFunc&#39;: True,
        &#39;resAsUint8&#39;: args.uint.value,
    })

    logger(level=&#34;info&#34;,
           message=&#34;Ot2Rec-RLFDeconv started.&#34;)

    my_deconv = RLF_deconv(
        rootname = args.project_name.value,
        suffix = args.file_suffix.value,
        raw_folder=str(args.raw_folder.value),
        kernel_folder=str(args.psf_folder.value),
        out_folder=str(args.output_folder.value),
        params_dict=deconv_params,
        orig_mrc=args.image_type.value == &#39;mrc&#39;,
        kernel_mrc=args.psf_type.value == &#39;mrc&#39;
    )

    deconvd_image = my_deconv()</code></pre>
</details>
</dd>
<dt id="Ot2Rec.rlf_deconv.tickCallBack"><code class="name flex">
<span>def <span class="ident">tickCallBack</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tickCallBack():
    global itick
    itick += 1</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Ot2Rec.rlf_deconv.RLF_deconv"><code class="flex name class">
<span>class <span class="ident">RLF_deconv</span></span>
<span>(</span><span>rootname, suffix, raw_folder, kernel_folder, out_folder, params_dict, orig_mrc, kernel_mrc)</span>
</code></dt>
<dd>
<div class="desc"><p>Class encapsulating an RLF_deconv object</p>
<p>Initialise the RLF_deconv object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rootname</code></strong> :&ensp;<code>str</code></dt>
<dd>rootname of project</dd>
<dt><strong><code>orig_folder</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>parent folder containing original images to be deconvolved</dd>
<dt><strong><code>kernel_folder</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>parent folder containing kernel with which the image is to be deconvolved</dd>
<dt><strong><code>out_folder</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>output parent folder for deconvolved tomograms</dd>
<dt><strong><code>params_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary containing all parameters used in RLF</dd>
<dt><strong><code>orig_mrc</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether the original image is in MRC format (TIFF if false)</dd>
<dt><strong><code>kernel_mrc</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether the kernel is in MRC format (TIFF if false)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RLF_deconv():
    &#34;&#34;&#34;
    Class encapsulating an RLF_deconv object
    &#34;&#34;&#34;
    def __init__(self, rootname, suffix, raw_folder, kernel_folder, out_folder, params_dict, orig_mrc, kernel_mrc):
        &#34;&#34;&#34;
        Initialise the RLF_deconv object

        Args:
            rootname (str): rootname of project
            orig_folder (ndarray): parent folder containing original images to be deconvolved
            kernel_folder (ndarray): parent folder containing kernel with which the image is to be deconvolved
            out_folder (ndarray): output parent folder for deconvolved tomograms
            params_dict (dict): dictionary containing all parameters used in RLF
            orig_mrc (bool): whether the original image is in MRC format (TIFF if false)
            kernel_mrc (bool): whether the kernel is in MRC format (TIFF if false)
        &#34;&#34;&#34;
        self.rootname = rootname
        self.suffix = suffix
        self.raw_folder = raw_folder
        self.kernel_folder = kernel_folder
        self.out_folder = out_folder
        self.params = params_dict
        self.orig_mrc = orig_mrc
        self.kernel_mrc = kernel_mrc

        # Initiating variables for later use
        self.orig = None
        self.kernel = None

        self._get_internal_metadata()


    def __call__(self):
        &#34;&#34;&#34;
        Method to start deconvolution
        &#34;&#34;&#34;
        self.out_files = []
        tqdm_iter = tqdm(range(len(self.plist)), ncols=100)

        for idx in tqdm_iter:
            self.orig_path = self.raw_files[idx]
            self.kernel_path = self.psf_files[idx]
            self.out_path = f&#34;{self.out_folder}/{self.plist[idx]}/{self.plist[idx]}_deconv.mrc&#34;

            # Read in raw image and kernel files
            if self.orig_mrc:
                self.orig = self.read_mrc(self.orig_path)
            else:
                self.orig = self.read_tiff(self.orig_path)

            self.orig = 256 * (self.orig-np.min(self.orig)) / np.ptp(self.orig)

            if self.kernel_mrc:
                self.kernel = np.flip(self.read_mrc(self.kernel_path))
            else:
                self.kernel = np.flip(self.read_tiff(self.kernel_path))

            # Deconvolve image
            out = self._deconv_array()

            # Save results
            with mrcfile.new(self.out_path, overwrite=True) as f:
                f.set_data(out)

            # Update output list
            self.out_files.append(self.out_path)

        # Update and export output metadata
        self.meta_out.outputs = self.out_files

        yaml_file = self.rootname + &#39;_rlf_deconv_mdout.yaml&#39;
        with open(yaml_file, &#39;w&#39;) as f:
            yaml.dump(self.meta_out.to_dict(), f, indent=4, sort_keys=False)



    @staticmethod
    def read_mrc(path):
        &#34;&#34;&#34;
        Method to read an MRC file and return a numpy array

        Returns:
            ndarray
        &#34;&#34;&#34;
        with mrcfile.open(path) as image:
            data = image.data

        return data


    @staticmethod
    def read_tiff(path):
        &#34;&#34;&#34;
        Method to read a TIFF file and return a numpy array

        Returns:
            ndarray
        &#34;&#34;&#34;
        data = tifffile.imread(path)

        return data


    def _deconv_array(self):
        &#34;&#34;&#34;
        Method to use RLF to deconvolve image
        &#34;&#34;&#34;

        image_deconvolved = rlf.doRLDeconvolutionFromNpArrays(
            self.orig, self.kernel,
            niter=self.params[&#39;niter&#39;],
            method=self.params[&#39;method&#39;].lower(),
            useBlockAlgorithm=self.params[&#39;useBlockAlgorithm&#39;],
            callbkTickFunc=tickCallBack(), # if self.params[&#39;callbkTickFunc&#39;] else None,
            resAsUint8=self.params[&#39;resAsUint8&#39;]
        )

        return image_deconvolved


    def _get_internal_metadata(self):
        &#34;&#34;&#34;
        Method to prepare internal metadata for processing and checking
        &#34;&#34;&#34;
        # Get process list
        raw_subfolders = (f&#34;{self.raw_folder}/&#34;
                          f&#34;{self.rootname}_*{self.suffix}&#34;)
        psf_subfolders = (f&#34;{self.kernel_folder}/&#34;
                          f&#34;{self.rootname}_*{self.suffix}&#34;)
        raw_set = set([i.split(&#34;/&#34;)[-1] for i in glob(raw_subfolders)])
        psf_set = set([i.split(&#34;/&#34;)[-1] for i in glob(psf_subfolders)])
        self.plist = sorted(list(raw_set &amp; psf_set))

        self.raw_files = []
        self.psf_files = []
        for proc in self.plist:
            # Create the folders and dictionary for future reference
            out_subfolders = f&#34;{self.out_folder}/{proc}&#34;
            os.makedirs(out_subfolders, exist_ok=True)

            # Find relevant files
            search = f&#34;{self.raw_folder}/{proc}/*_rec.mrc&#34;
            exclude = f&#34;{self.raw_folder}/{proc}/*_full_rec.mrc&#34;
            file_clean = list(set(glob(search))-set(glob(exclude)))[0]

            self.raw_files.append(file_clean)
            self.psf_files.append(glob(f&#34;{self.kernel_folder}/{proc}/*_PSF.mrc&#34;)[0])

        assert(len(self.raw_files)==len(self.psf_files)), \
            &#34;ERROR: lengths of raw and PSF file list not equal. File missing?&#34;

        self.meta_out = pd.DataFrame(columns=[&#39;raw_files&#39;, &#39;psf_files&#39;, &#39;outputs&#39;])
        self.meta_out.raw_files = self.raw_files
        self.meta_out.psf_files = self.psf_files</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Ot2Rec.rlf_deconv.RLF_deconv.read_mrc"><code class="name flex">
<span>def <span class="ident">read_mrc</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to read an MRC file and return a numpy array</p>
<h2 id="returns">Returns</h2>
<p>ndarray</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read_mrc(path):
    &#34;&#34;&#34;
    Method to read an MRC file and return a numpy array

    Returns:
        ndarray
    &#34;&#34;&#34;
    with mrcfile.open(path) as image:
        data = image.data

    return data</code></pre>
</details>
</dd>
<dt id="Ot2Rec.rlf_deconv.RLF_deconv.read_tiff"><code class="name flex">
<span>def <span class="ident">read_tiff</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to read a TIFF file and return a numpy array</p>
<h2 id="returns">Returns</h2>
<p>ndarray</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read_tiff(path):
    &#34;&#34;&#34;
    Method to read a TIFF file and return a numpy array

    Returns:
        ndarray
    &#34;&#34;&#34;
    data = tifffile.imread(path)

    return data</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Ot2Rec" href="index.html">Ot2Rec</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Ot2Rec.rlf_deconv.run" href="#Ot2Rec.rlf_deconv.run">run</a></code></li>
<li><code><a title="Ot2Rec.rlf_deconv.tickCallBack" href="#Ot2Rec.rlf_deconv.tickCallBack">tickCallBack</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Ot2Rec.rlf_deconv.RLF_deconv" href="#Ot2Rec.rlf_deconv.RLF_deconv">RLF_deconv</a></code></h4>
<ul class="">
<li><code><a title="Ot2Rec.rlf_deconv.RLF_deconv.read_mrc" href="#Ot2Rec.rlf_deconv.RLF_deconv.read_mrc">read_mrc</a></code></li>
<li><code><a title="Ot2Rec.rlf_deconv.RLF_deconv.read_tiff" href="#Ot2Rec.rlf_deconv.RLF_deconv.read_tiff">read_tiff</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>