<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Ot2Rec.metadata API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Ot2Rec.metadata</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 Rosalind Franklin Institute
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the License for the specific
# language governing permissions and limitations under the License.


import os
import re
import itertools
from functools import partial
import multiprocessing as mp
import subprocess
from glob import glob

import yaml
import mdocfile as mdf
import pandas as pd
from icecream import ic

from . import params as prmMod


class Metadata:
    &#34;&#34;&#34;
    Class encapsulating Metadata objects
    &#34;&#34;&#34;

    # First define conversion table between job (module) name and file suffixes
    suffix_dict = {
        &#39;master&#39;: &#39;proj&#39;,
        &#39;motioncorr&#39;: &#39;mc2&#39;,
        &#39;ctffind&#39;: &#39;ctffind&#39;,
        &#39;align&#39;: &#39;align&#39;,
        &#39;reconstruct&#39;: &#39;recon&#39;,
    }

    def __init__(self,
                 project_name: str,
                 job_type: str,
                 md_in=None,
                 ):
        &#34;&#34;&#34;
        Initialise Metadata object

        Args:
            project_name: project name
            job_type: what job is being done 
                (motioncorr/ctffind/align/reconstruct)
            md_in: dictionary read from yaml file containing existing metadata
        &#34;&#34;&#34;

        self.project_name = project_name
        self.job_type = job_type
        self.metadata = md_in

        # Obtain parameters first
        if self.job_type in [&#39;master&#39;, &#39;motioncorr&#39;, &#39;ctffind&#39;, &#39;align&#39;, &#39;reconstruct&#39;]:
            self.get_param()

        # Define empty lists for later use
        self.image_paths, self.tilt_series, self.image_idx, self.tilt_angles = [], [], [], []

    def get_param(self):
        &#34;&#34;&#34;
        Subroutine to get parameters for current job
        &#34;&#34;&#34;

        param_file = self.project_name + &#39;_&#39; + Metadata.suffix_dict[self.job_type] + &#39;.yaml&#39;
        self.prmObj = prmMod.read_yaml(project_name=self.project_name,
                                       filename=param_file)
        self.params = self.prmObj.params

    def create_master_metadata(self):
        &#34;&#34;&#34;
        Subroutine to create master metadata from raw data.
        Metadata include: image paths, tilt series indices, tilt angles
        &#34;&#34;&#34;

        # Define criteria for searching subfolders (tilt series) within source folder
        if self.params[&#39;TS_folder_prefix&#39;] == &#39;*&#39;:
            ts_subfolder_criterion = &#39;*&#39;
        elif self.params[&#39;TS_folder_prefix&#39;] != &#39;*&#39; and \
                len(self.params[&#39;TS_folder_prefix&#39;]) &gt; 0:
            ts_subfolder_criterion = self.params[&#39;TS_folder_prefix&#39;] + &#39;_*&#39;

        # Source folder should not end with forward slash so remove them
        while self.params[&#39;source_folder&#39;].endswith(&#39;/&#39;):
            self.params[&#39;source_folder&#39;] = self.params[&#39;source_folder&#39;][:-1]

        # Find files and check
        if len(self.params[&#39;TS_folder_prefix&#39;]) &gt; 0:
            raw_images_list = glob(&#34;{}/{}/{}_*.{}&#34;.format(
                self.params[&#39;source_folder&#39;],
                ts_subfolder_criterion,
                self.params[&#39;file_prefix&#39;],
                self.params[&#39;filetype&#39;])
            )
        else:
            raw_images_list = glob(&#34;{}/{}_*.{}&#34;.format(
                self.params[&#39;source_folder&#39;],
                self.params[&#39;file_prefix&#39;],
                self.params[&#39;filetype&#39;])
            )

        if (len(raw_images_list) == 0):
            raise IOError(&#34;Error in Ot2Rec.metadata.Metadata.create_master_metadata: &#34;
                          &#34;No vaild files found using given criteria.&#34;)

        # Convert potentially relative file paths to absolute paths
        raw_images_list = sorted([os.path.abspath(image) for image in raw_images_list])

        # Extract information from image file names
        for curr_image in raw_images_list:
            self.image_paths.append(curr_image)

            # Get length of filename prefix
            prefix_length = len(self.params[&#39;file_prefix&#39;].split(&#39;_&#39;))

            # Extract tilt series number
            split_path_name = curr_image.split(&#39;/&#39;)[-1].replace(&#39;[&#39;, &#39;_&#39;).split(&#39;_&#39;)
            try:
                ts_index = int(&#39;&#39;.join(i for i in split_path_name[
                    self.params[&#39;image_stack_field&#39;] + prefix_length] if i.isdigit()))
            except (IndexError, ValueError):
                raise IndexError(f&#34;Error in Ot2Rec.metadata.Metadata.create_master_metadata. &#34;
                                 f&#34;Failed to get tilt series number from file path {curr_image}.&#34;)
            self.tilt_series.append(ts_index)

            # Extract image index number
            try:
                idx = int(&#39;&#39;.join(i for i in split_path_name[self.params[&#39;image_index_field&#39;] + prefix_length]
                                  if i.isdigit()))
            except (IndexError, ValueError):
                raise IndexError(f&#34;Error in Ot2Rec.metadata.Metadata.create_master_metadata. &#34;
                                 f&#34;Failed to get tilt series number from file path {curr_image}.&#34;)
            self.image_idx.append(idx)

            # Extract tilt angle
            try:
                tilt_angle = float(split_path_name[self.params[&#39;image_tiltangle_field&#39;] + prefix_length].replace(
                    f&#34;.{self.params[&#39;filetype&#39;]}&#34;, &#39;&#39;).replace(&#39;[&#39;, &#39;&#39;).replace(&#39;]&#39;, &#39;&#39;))
            except (IndexError, ValueError):
                raise IndexError(f&#34;Error in Ot2Rec.metadata.Metadata.create_master_metadata. &#34;
                                 f&#34;Failed to get tilt angle from file path {curr_image}.&#34;)
            self.tilt_angles.append(tilt_angle)

        # Save metadata as a dictionary --- easier to dump as yaml
        self.metadata = dict(file_paths=self.image_paths,
                             ts=[int(i) for i in self.tilt_series],
                             image_idx=[int(i) for i in self.image_idx],
                             angles=self.tilt_angles,
        )

    @staticmethod
    def get_num_frames(curr_file, target_frames):
        &#34;&#34;&#34;
        Get number of frames from the micrograph

        Args:
            curr_file (str): path to current file
            target_frames (int): target number of frames in the &#39;mrc&#39;
        &#34;&#34;&#34;

        command = [&#34;header&#34;, curr_file]
        text = subprocess.run(command, capture_output=True, check=True)

        text_split = str(text.stdout).split(&#39;\\n&#39;)

        r = re.compile(r&#39;^\s*Number&#39;)
        line = list(filter(r.match, text_split))[0].lstrip()

        num_frames = int(re.split(r&#39;\s+&#39;, line)[-1])
        sampling = max(1, num_frames // target_frames)

        return [num_frames, sampling]

    @staticmethod
    def get_num_frames_parallel(func, filelist, target_frames=15, np=8):
        &#34;&#34;&#34;
        Args:
            func (func): function to be parallelised
            filelist (list): list of image files to be passed into the function
        &#34;&#34;&#34;
        func_filelist = partial(func, target_frames=target_frames)
        with mp.Pool(np) as p:
            result = p.map(func_filelist, filelist)

        return result

    @staticmethod
    def get_ts_dose(mdoc_in, start=0):
        with open(mdoc_in, &#39;r&#39;) as f:
            lines = f.readlines()
            lines = [line.rstrip() for line in lines]

        blocks = [list(y) for x, y in itertools.groupby(lines, lambda z: z == &#39;&#39;) if not x]
        ts_all_info = [block for block in blocks if block[0].startswith(r&#39;[ZValue&#39;)]

        ts_dose_dict = {}
        for frame_idx in range(len(ts_all_info)):
            file_idx = frame_idx + start

            image = ts_all_info[frame_idx]
            image_split = [re.split(r&#39;\s*=\s*&#39;, line) for line in image]
            image_split_t = list(map(list, zip(*image_split)))
            image_dict = dict(zip(image_split_t[0], image_split_t[1]))

            ts_dose_dict[file_idx] = float(image_dict[&#39;ExposureDose&#39;])

        return ts_dose_dict


    def get_mc2_temp(self):
        df = pd.DataFrame(self.metadata)
        base_folder = &#39;/&#39;.join(df.file_paths.values[0].split(&#39;/&#39;)[:-1])

        df[&#39;num_frames&#39;] = None
        df[&#39;ds_factor&#39;] = None
        df[&#39;frame_dose&#39;] = None
        for curr_ts in list(set(df.ts)):
            mdoc_path = f&#34;{base_folder}/{self.params[&#39;file_prefix&#39;]}_&#34; + str(curr_ts) + &#34;.mdoc&#34;
            mdoc = mdf.read(mdoc_path)
            ts_dose_dict = self.get_ts_dose(mdoc_path, 1)

            ts_image_list = df[df[&#39;ts&#39;] == curr_ts][&#39;file_paths&#39;].to_list()
            ts_image_idx_list = df[df[&#39;ts&#39;] == curr_ts][&#39;image_idx&#39;].to_list()
            ts_num_frame_list = self.get_num_frames_parallel(func=self.get_num_frames,
                                                             filelist=ts_image_list,
                                                             )

            for curr_idx in ts_image_idx_list:
                nf, dsf = ts_num_frame_list[curr_idx - 1]
                df.loc[(df.ts == curr_ts) &amp; (df.image_idx == curr_idx), &#39;num_frames&#39;] = nf
                df.loc[(df.ts == curr_ts) &amp; (df.image_idx == curr_idx), &#39;ds_factor&#39;] = dsf
                df.loc[(df.ts == curr_ts) &amp; (df.image_idx == curr_idx), &#39;frame_dose&#39;] = ts_dose_dict[curr_idx] / nf

        self.metadata[&#39;num_frames&#39;] = df.num_frames.to_list()
        self.metadata[&#39;ds_factor&#39;] = df.ds_factor.to_list()
        self.metadata[&#39;frame_dose&#39;] = df.frame_dose.to_list()


    def get_acquisition_settings(self):
        df = pd.DataFrame(self.metadata)
        base_folder = &#39;/&#39;.join(df.file_paths.values[0].split(&#39;/&#39;)[:-1])

        ts = list(set(df.ts))[0] # Assuming settings same across one data set
        mdoc_path = f&#34;{base_folder}/{self.params[&#39;file_prefix&#39;]}_&#34; + str(ts) + &#34;.mdoc&#34;
        mdoc = mdf.read(mdoc_path)

        self.metadata[&#39;magnification&#39;] = int(mdoc.magnification.unique()[0])
        self.metadata[&#39;pixel_spacing&#39;] = float(mdoc.pixel_spacing.unique()[0])
        self.metadata[&#39;spot_size&#39;] = float(mdoc.spot_size.unique()[0])
        self.metadata[&#39;rotation_angle&#39;] = float(mdoc.rotation_angle.unique()[0])
        self.metadata[&#39;voltage&#39;] = float(mdoc.voltage.unique()[0])
        self.metadata[&#39;image_size&#39;] = list(mdoc.image_size.unique()[0])


def read_md_yaml(project_name: str,
                 job_type: str,
                 filename: str,
                 ):
    &#34;&#34;&#34;
    Function to read in YAML file containing metadata

    Args:
        project_name: Name of current project
        job_type: what job is being done (motioncorr/ctffind/align/reconstruct)
        filename: Name of the YAML file to be read

    Returns:
        ot2rec.metadata.Metadata
    &#34;&#34;&#34;

    # Check if file exists
    if not os.path.isfile(filename):
        raise IOError(&#34;Error in Ot2Rec.metadata.read_md_yaml: File not found.&#34;)

    with open(filename, &#39;r&#39;) as f:
        md = yaml.load(f, Loader=yaml.FullLoader)

    return Metadata(project_name=project_name,
                    job_type=job_type,
                    md_in=md)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Ot2Rec.metadata.read_md_yaml"><code class="name flex">
<span>def <span class="ident">read_md_yaml</span></span>(<span>project_name: str, job_type: str, filename: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to read in YAML file containing metadata</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>project_name</code></strong></dt>
<dd>Name of current project</dd>
<dt><strong><code>job_type</code></strong></dt>
<dd>what job is being done (motioncorr/ctffind/align/reconstruct)</dd>
<dt><strong><code>filename</code></strong></dt>
<dd>Name of the YAML file to be read</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ot2rec.metadata.Metadata</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_md_yaml(project_name: str,
                 job_type: str,
                 filename: str,
                 ):
    &#34;&#34;&#34;
    Function to read in YAML file containing metadata

    Args:
        project_name: Name of current project
        job_type: what job is being done (motioncorr/ctffind/align/reconstruct)
        filename: Name of the YAML file to be read

    Returns:
        ot2rec.metadata.Metadata
    &#34;&#34;&#34;

    # Check if file exists
    if not os.path.isfile(filename):
        raise IOError(&#34;Error in Ot2Rec.metadata.read_md_yaml: File not found.&#34;)

    with open(filename, &#39;r&#39;) as f:
        md = yaml.load(f, Loader=yaml.FullLoader)

    return Metadata(project_name=project_name,
                    job_type=job_type,
                    md_in=md)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Ot2Rec.metadata.Metadata"><code class="flex name class">
<span>class <span class="ident">Metadata</span></span>
<span>(</span><span>project_name: str, job_type: str, md_in=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class encapsulating Metadata objects</p>
<p>Initialise Metadata object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>project_name</code></strong></dt>
<dd>project name</dd>
<dt><strong><code>job_type</code></strong></dt>
<dd>what job is being done
(motioncorr/ctffind/align/reconstruct)</dd>
<dt><strong><code>md_in</code></strong></dt>
<dd>dictionary read from yaml file containing existing metadata</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Metadata:
    &#34;&#34;&#34;
    Class encapsulating Metadata objects
    &#34;&#34;&#34;

    # First define conversion table between job (module) name and file suffixes
    suffix_dict = {
        &#39;master&#39;: &#39;proj&#39;,
        &#39;motioncorr&#39;: &#39;mc2&#39;,
        &#39;ctffind&#39;: &#39;ctffind&#39;,
        &#39;align&#39;: &#39;align&#39;,
        &#39;reconstruct&#39;: &#39;recon&#39;,
    }

    def __init__(self,
                 project_name: str,
                 job_type: str,
                 md_in=None,
                 ):
        &#34;&#34;&#34;
        Initialise Metadata object

        Args:
            project_name: project name
            job_type: what job is being done 
                (motioncorr/ctffind/align/reconstruct)
            md_in: dictionary read from yaml file containing existing metadata
        &#34;&#34;&#34;

        self.project_name = project_name
        self.job_type = job_type
        self.metadata = md_in

        # Obtain parameters first
        if self.job_type in [&#39;master&#39;, &#39;motioncorr&#39;, &#39;ctffind&#39;, &#39;align&#39;, &#39;reconstruct&#39;]:
            self.get_param()

        # Define empty lists for later use
        self.image_paths, self.tilt_series, self.image_idx, self.tilt_angles = [], [], [], []

    def get_param(self):
        &#34;&#34;&#34;
        Subroutine to get parameters for current job
        &#34;&#34;&#34;

        param_file = self.project_name + &#39;_&#39; + Metadata.suffix_dict[self.job_type] + &#39;.yaml&#39;
        self.prmObj = prmMod.read_yaml(project_name=self.project_name,
                                       filename=param_file)
        self.params = self.prmObj.params

    def create_master_metadata(self):
        &#34;&#34;&#34;
        Subroutine to create master metadata from raw data.
        Metadata include: image paths, tilt series indices, tilt angles
        &#34;&#34;&#34;

        # Define criteria for searching subfolders (tilt series) within source folder
        if self.params[&#39;TS_folder_prefix&#39;] == &#39;*&#39;:
            ts_subfolder_criterion = &#39;*&#39;
        elif self.params[&#39;TS_folder_prefix&#39;] != &#39;*&#39; and \
                len(self.params[&#39;TS_folder_prefix&#39;]) &gt; 0:
            ts_subfolder_criterion = self.params[&#39;TS_folder_prefix&#39;] + &#39;_*&#39;

        # Source folder should not end with forward slash so remove them
        while self.params[&#39;source_folder&#39;].endswith(&#39;/&#39;):
            self.params[&#39;source_folder&#39;] = self.params[&#39;source_folder&#39;][:-1]

        # Find files and check
        if len(self.params[&#39;TS_folder_prefix&#39;]) &gt; 0:
            raw_images_list = glob(&#34;{}/{}/{}_*.{}&#34;.format(
                self.params[&#39;source_folder&#39;],
                ts_subfolder_criterion,
                self.params[&#39;file_prefix&#39;],
                self.params[&#39;filetype&#39;])
            )
        else:
            raw_images_list = glob(&#34;{}/{}_*.{}&#34;.format(
                self.params[&#39;source_folder&#39;],
                self.params[&#39;file_prefix&#39;],
                self.params[&#39;filetype&#39;])
            )

        if (len(raw_images_list) == 0):
            raise IOError(&#34;Error in Ot2Rec.metadata.Metadata.create_master_metadata: &#34;
                          &#34;No vaild files found using given criteria.&#34;)

        # Convert potentially relative file paths to absolute paths
        raw_images_list = sorted([os.path.abspath(image) for image in raw_images_list])

        # Extract information from image file names
        for curr_image in raw_images_list:
            self.image_paths.append(curr_image)

            # Get length of filename prefix
            prefix_length = len(self.params[&#39;file_prefix&#39;].split(&#39;_&#39;))

            # Extract tilt series number
            split_path_name = curr_image.split(&#39;/&#39;)[-1].replace(&#39;[&#39;, &#39;_&#39;).split(&#39;_&#39;)
            try:
                ts_index = int(&#39;&#39;.join(i for i in split_path_name[
                    self.params[&#39;image_stack_field&#39;] + prefix_length] if i.isdigit()))
            except (IndexError, ValueError):
                raise IndexError(f&#34;Error in Ot2Rec.metadata.Metadata.create_master_metadata. &#34;
                                 f&#34;Failed to get tilt series number from file path {curr_image}.&#34;)
            self.tilt_series.append(ts_index)

            # Extract image index number
            try:
                idx = int(&#39;&#39;.join(i for i in split_path_name[self.params[&#39;image_index_field&#39;] + prefix_length]
                                  if i.isdigit()))
            except (IndexError, ValueError):
                raise IndexError(f&#34;Error in Ot2Rec.metadata.Metadata.create_master_metadata. &#34;
                                 f&#34;Failed to get tilt series number from file path {curr_image}.&#34;)
            self.image_idx.append(idx)

            # Extract tilt angle
            try:
                tilt_angle = float(split_path_name[self.params[&#39;image_tiltangle_field&#39;] + prefix_length].replace(
                    f&#34;.{self.params[&#39;filetype&#39;]}&#34;, &#39;&#39;).replace(&#39;[&#39;, &#39;&#39;).replace(&#39;]&#39;, &#39;&#39;))
            except (IndexError, ValueError):
                raise IndexError(f&#34;Error in Ot2Rec.metadata.Metadata.create_master_metadata. &#34;
                                 f&#34;Failed to get tilt angle from file path {curr_image}.&#34;)
            self.tilt_angles.append(tilt_angle)

        # Save metadata as a dictionary --- easier to dump as yaml
        self.metadata = dict(file_paths=self.image_paths,
                             ts=[int(i) for i in self.tilt_series],
                             image_idx=[int(i) for i in self.image_idx],
                             angles=self.tilt_angles,
        )

    @staticmethod
    def get_num_frames(curr_file, target_frames):
        &#34;&#34;&#34;
        Get number of frames from the micrograph

        Args:
            curr_file (str): path to current file
            target_frames (int): target number of frames in the &#39;mrc&#39;
        &#34;&#34;&#34;

        command = [&#34;header&#34;, curr_file]
        text = subprocess.run(command, capture_output=True, check=True)

        text_split = str(text.stdout).split(&#39;\\n&#39;)

        r = re.compile(r&#39;^\s*Number&#39;)
        line = list(filter(r.match, text_split))[0].lstrip()

        num_frames = int(re.split(r&#39;\s+&#39;, line)[-1])
        sampling = max(1, num_frames // target_frames)

        return [num_frames, sampling]

    @staticmethod
    def get_num_frames_parallel(func, filelist, target_frames=15, np=8):
        &#34;&#34;&#34;
        Args:
            func (func): function to be parallelised
            filelist (list): list of image files to be passed into the function
        &#34;&#34;&#34;
        func_filelist = partial(func, target_frames=target_frames)
        with mp.Pool(np) as p:
            result = p.map(func_filelist, filelist)

        return result

    @staticmethod
    def get_ts_dose(mdoc_in, start=0):
        with open(mdoc_in, &#39;r&#39;) as f:
            lines = f.readlines()
            lines = [line.rstrip() for line in lines]

        blocks = [list(y) for x, y in itertools.groupby(lines, lambda z: z == &#39;&#39;) if not x]
        ts_all_info = [block for block in blocks if block[0].startswith(r&#39;[ZValue&#39;)]

        ts_dose_dict = {}
        for frame_idx in range(len(ts_all_info)):
            file_idx = frame_idx + start

            image = ts_all_info[frame_idx]
            image_split = [re.split(r&#39;\s*=\s*&#39;, line) for line in image]
            image_split_t = list(map(list, zip(*image_split)))
            image_dict = dict(zip(image_split_t[0], image_split_t[1]))

            ts_dose_dict[file_idx] = float(image_dict[&#39;ExposureDose&#39;])

        return ts_dose_dict


    def get_mc2_temp(self):
        df = pd.DataFrame(self.metadata)
        base_folder = &#39;/&#39;.join(df.file_paths.values[0].split(&#39;/&#39;)[:-1])

        df[&#39;num_frames&#39;] = None
        df[&#39;ds_factor&#39;] = None
        df[&#39;frame_dose&#39;] = None
        for curr_ts in list(set(df.ts)):
            mdoc_path = f&#34;{base_folder}/{self.params[&#39;file_prefix&#39;]}_&#34; + str(curr_ts) + &#34;.mdoc&#34;
            mdoc = mdf.read(mdoc_path)
            ts_dose_dict = self.get_ts_dose(mdoc_path, 1)

            ts_image_list = df[df[&#39;ts&#39;] == curr_ts][&#39;file_paths&#39;].to_list()
            ts_image_idx_list = df[df[&#39;ts&#39;] == curr_ts][&#39;image_idx&#39;].to_list()
            ts_num_frame_list = self.get_num_frames_parallel(func=self.get_num_frames,
                                                             filelist=ts_image_list,
                                                             )

            for curr_idx in ts_image_idx_list:
                nf, dsf = ts_num_frame_list[curr_idx - 1]
                df.loc[(df.ts == curr_ts) &amp; (df.image_idx == curr_idx), &#39;num_frames&#39;] = nf
                df.loc[(df.ts == curr_ts) &amp; (df.image_idx == curr_idx), &#39;ds_factor&#39;] = dsf
                df.loc[(df.ts == curr_ts) &amp; (df.image_idx == curr_idx), &#39;frame_dose&#39;] = ts_dose_dict[curr_idx] / nf

        self.metadata[&#39;num_frames&#39;] = df.num_frames.to_list()
        self.metadata[&#39;ds_factor&#39;] = df.ds_factor.to_list()
        self.metadata[&#39;frame_dose&#39;] = df.frame_dose.to_list()


    def get_acquisition_settings(self):
        df = pd.DataFrame(self.metadata)
        base_folder = &#39;/&#39;.join(df.file_paths.values[0].split(&#39;/&#39;)[:-1])

        ts = list(set(df.ts))[0] # Assuming settings same across one data set
        mdoc_path = f&#34;{base_folder}/{self.params[&#39;file_prefix&#39;]}_&#34; + str(ts) + &#34;.mdoc&#34;
        mdoc = mdf.read(mdoc_path)

        self.metadata[&#39;magnification&#39;] = int(mdoc.magnification.unique()[0])
        self.metadata[&#39;pixel_spacing&#39;] = float(mdoc.pixel_spacing.unique()[0])
        self.metadata[&#39;spot_size&#39;] = float(mdoc.spot_size.unique()[0])
        self.metadata[&#39;rotation_angle&#39;] = float(mdoc.rotation_angle.unique()[0])
        self.metadata[&#39;voltage&#39;] = float(mdoc.voltage.unique()[0])
        self.metadata[&#39;image_size&#39;] = list(mdoc.image_size.unique()[0])</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="Ot2Rec.metadata.Metadata.suffix_dict"><code class="name">var <span class="ident">suffix_dict</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="Ot2Rec.metadata.Metadata.get_num_frames"><code class="name flex">
<span>def <span class="ident">get_num_frames</span></span>(<span>curr_file, target_frames)</span>
</code></dt>
<dd>
<div class="desc"><p>Get number of frames from the micrograph</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>curr_file</code></strong> :&ensp;<code>str</code></dt>
<dd>path to current file</dd>
<dt><strong><code>target_frames</code></strong> :&ensp;<code>int</code></dt>
<dd>target number of frames in the 'mrc'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_num_frames(curr_file, target_frames):
    &#34;&#34;&#34;
    Get number of frames from the micrograph

    Args:
        curr_file (str): path to current file
        target_frames (int): target number of frames in the &#39;mrc&#39;
    &#34;&#34;&#34;

    command = [&#34;header&#34;, curr_file]
    text = subprocess.run(command, capture_output=True, check=True)

    text_split = str(text.stdout).split(&#39;\\n&#39;)

    r = re.compile(r&#39;^\s*Number&#39;)
    line = list(filter(r.match, text_split))[0].lstrip()

    num_frames = int(re.split(r&#39;\s+&#39;, line)[-1])
    sampling = max(1, num_frames // target_frames)

    return [num_frames, sampling]</code></pre>
</details>
</dd>
<dt id="Ot2Rec.metadata.Metadata.get_num_frames_parallel"><code class="name flex">
<span>def <span class="ident">get_num_frames_parallel</span></span>(<span>func, filelist, target_frames=15, np=8)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>func</code></dt>
<dd>function to be parallelised</dd>
<dt><strong><code>filelist</code></strong> :&ensp;<code>list</code></dt>
<dd>list of image files to be passed into the function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_num_frames_parallel(func, filelist, target_frames=15, np=8):
    &#34;&#34;&#34;
    Args:
        func (func): function to be parallelised
        filelist (list): list of image files to be passed into the function
    &#34;&#34;&#34;
    func_filelist = partial(func, target_frames=target_frames)
    with mp.Pool(np) as p:
        result = p.map(func_filelist, filelist)

    return result</code></pre>
</details>
</dd>
<dt id="Ot2Rec.metadata.Metadata.get_ts_dose"><code class="name flex">
<span>def <span class="ident">get_ts_dose</span></span>(<span>mdoc_in, start=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_ts_dose(mdoc_in, start=0):
    with open(mdoc_in, &#39;r&#39;) as f:
        lines = f.readlines()
        lines = [line.rstrip() for line in lines]

    blocks = [list(y) for x, y in itertools.groupby(lines, lambda z: z == &#39;&#39;) if not x]
    ts_all_info = [block for block in blocks if block[0].startswith(r&#39;[ZValue&#39;)]

    ts_dose_dict = {}
    for frame_idx in range(len(ts_all_info)):
        file_idx = frame_idx + start

        image = ts_all_info[frame_idx]
        image_split = [re.split(r&#39;\s*=\s*&#39;, line) for line in image]
        image_split_t = list(map(list, zip(*image_split)))
        image_dict = dict(zip(image_split_t[0], image_split_t[1]))

        ts_dose_dict[file_idx] = float(image_dict[&#39;ExposureDose&#39;])

    return ts_dose_dict</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Ot2Rec.metadata.Metadata.create_master_metadata"><code class="name flex">
<span>def <span class="ident">create_master_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Subroutine to create master metadata from raw data.
Metadata include: image paths, tilt series indices, tilt angles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_master_metadata(self):
    &#34;&#34;&#34;
    Subroutine to create master metadata from raw data.
    Metadata include: image paths, tilt series indices, tilt angles
    &#34;&#34;&#34;

    # Define criteria for searching subfolders (tilt series) within source folder
    if self.params[&#39;TS_folder_prefix&#39;] == &#39;*&#39;:
        ts_subfolder_criterion = &#39;*&#39;
    elif self.params[&#39;TS_folder_prefix&#39;] != &#39;*&#39; and \
            len(self.params[&#39;TS_folder_prefix&#39;]) &gt; 0:
        ts_subfolder_criterion = self.params[&#39;TS_folder_prefix&#39;] + &#39;_*&#39;

    # Source folder should not end with forward slash so remove them
    while self.params[&#39;source_folder&#39;].endswith(&#39;/&#39;):
        self.params[&#39;source_folder&#39;] = self.params[&#39;source_folder&#39;][:-1]

    # Find files and check
    if len(self.params[&#39;TS_folder_prefix&#39;]) &gt; 0:
        raw_images_list = glob(&#34;{}/{}/{}_*.{}&#34;.format(
            self.params[&#39;source_folder&#39;],
            ts_subfolder_criterion,
            self.params[&#39;file_prefix&#39;],
            self.params[&#39;filetype&#39;])
        )
    else:
        raw_images_list = glob(&#34;{}/{}_*.{}&#34;.format(
            self.params[&#39;source_folder&#39;],
            self.params[&#39;file_prefix&#39;],
            self.params[&#39;filetype&#39;])
        )

    if (len(raw_images_list) == 0):
        raise IOError(&#34;Error in Ot2Rec.metadata.Metadata.create_master_metadata: &#34;
                      &#34;No vaild files found using given criteria.&#34;)

    # Convert potentially relative file paths to absolute paths
    raw_images_list = sorted([os.path.abspath(image) for image in raw_images_list])

    # Extract information from image file names
    for curr_image in raw_images_list:
        self.image_paths.append(curr_image)

        # Get length of filename prefix
        prefix_length = len(self.params[&#39;file_prefix&#39;].split(&#39;_&#39;))

        # Extract tilt series number
        split_path_name = curr_image.split(&#39;/&#39;)[-1].replace(&#39;[&#39;, &#39;_&#39;).split(&#39;_&#39;)
        try:
            ts_index = int(&#39;&#39;.join(i for i in split_path_name[
                self.params[&#39;image_stack_field&#39;] + prefix_length] if i.isdigit()))
        except (IndexError, ValueError):
            raise IndexError(f&#34;Error in Ot2Rec.metadata.Metadata.create_master_metadata. &#34;
                             f&#34;Failed to get tilt series number from file path {curr_image}.&#34;)
        self.tilt_series.append(ts_index)

        # Extract image index number
        try:
            idx = int(&#39;&#39;.join(i for i in split_path_name[self.params[&#39;image_index_field&#39;] + prefix_length]
                              if i.isdigit()))
        except (IndexError, ValueError):
            raise IndexError(f&#34;Error in Ot2Rec.metadata.Metadata.create_master_metadata. &#34;
                             f&#34;Failed to get tilt series number from file path {curr_image}.&#34;)
        self.image_idx.append(idx)

        # Extract tilt angle
        try:
            tilt_angle = float(split_path_name[self.params[&#39;image_tiltangle_field&#39;] + prefix_length].replace(
                f&#34;.{self.params[&#39;filetype&#39;]}&#34;, &#39;&#39;).replace(&#39;[&#39;, &#39;&#39;).replace(&#39;]&#39;, &#39;&#39;))
        except (IndexError, ValueError):
            raise IndexError(f&#34;Error in Ot2Rec.metadata.Metadata.create_master_metadata. &#34;
                             f&#34;Failed to get tilt angle from file path {curr_image}.&#34;)
        self.tilt_angles.append(tilt_angle)

    # Save metadata as a dictionary --- easier to dump as yaml
    self.metadata = dict(file_paths=self.image_paths,
                         ts=[int(i) for i in self.tilt_series],
                         image_idx=[int(i) for i in self.image_idx],
                         angles=self.tilt_angles,
    )</code></pre>
</details>
</dd>
<dt id="Ot2Rec.metadata.Metadata.get_acquisition_settings"><code class="name flex">
<span>def <span class="ident">get_acquisition_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_acquisition_settings(self):
    df = pd.DataFrame(self.metadata)
    base_folder = &#39;/&#39;.join(df.file_paths.values[0].split(&#39;/&#39;)[:-1])

    ts = list(set(df.ts))[0] # Assuming settings same across one data set
    mdoc_path = f&#34;{base_folder}/{self.params[&#39;file_prefix&#39;]}_&#34; + str(ts) + &#34;.mdoc&#34;
    mdoc = mdf.read(mdoc_path)

    self.metadata[&#39;magnification&#39;] = int(mdoc.magnification.unique()[0])
    self.metadata[&#39;pixel_spacing&#39;] = float(mdoc.pixel_spacing.unique()[0])
    self.metadata[&#39;spot_size&#39;] = float(mdoc.spot_size.unique()[0])
    self.metadata[&#39;rotation_angle&#39;] = float(mdoc.rotation_angle.unique()[0])
    self.metadata[&#39;voltage&#39;] = float(mdoc.voltage.unique()[0])
    self.metadata[&#39;image_size&#39;] = list(mdoc.image_size.unique()[0])</code></pre>
</details>
</dd>
<dt id="Ot2Rec.metadata.Metadata.get_mc2_temp"><code class="name flex">
<span>def <span class="ident">get_mc2_temp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mc2_temp(self):
    df = pd.DataFrame(self.metadata)
    base_folder = &#39;/&#39;.join(df.file_paths.values[0].split(&#39;/&#39;)[:-1])

    df[&#39;num_frames&#39;] = None
    df[&#39;ds_factor&#39;] = None
    df[&#39;frame_dose&#39;] = None
    for curr_ts in list(set(df.ts)):
        mdoc_path = f&#34;{base_folder}/{self.params[&#39;file_prefix&#39;]}_&#34; + str(curr_ts) + &#34;.mdoc&#34;
        mdoc = mdf.read(mdoc_path)
        ts_dose_dict = self.get_ts_dose(mdoc_path, 1)

        ts_image_list = df[df[&#39;ts&#39;] == curr_ts][&#39;file_paths&#39;].to_list()
        ts_image_idx_list = df[df[&#39;ts&#39;] == curr_ts][&#39;image_idx&#39;].to_list()
        ts_num_frame_list = self.get_num_frames_parallel(func=self.get_num_frames,
                                                         filelist=ts_image_list,
                                                         )

        for curr_idx in ts_image_idx_list:
            nf, dsf = ts_num_frame_list[curr_idx - 1]
            df.loc[(df.ts == curr_ts) &amp; (df.image_idx == curr_idx), &#39;num_frames&#39;] = nf
            df.loc[(df.ts == curr_ts) &amp; (df.image_idx == curr_idx), &#39;ds_factor&#39;] = dsf
            df.loc[(df.ts == curr_ts) &amp; (df.image_idx == curr_idx), &#39;frame_dose&#39;] = ts_dose_dict[curr_idx] / nf

    self.metadata[&#39;num_frames&#39;] = df.num_frames.to_list()
    self.metadata[&#39;ds_factor&#39;] = df.ds_factor.to_list()
    self.metadata[&#39;frame_dose&#39;] = df.frame_dose.to_list()</code></pre>
</details>
</dd>
<dt id="Ot2Rec.metadata.Metadata.get_param"><code class="name flex">
<span>def <span class="ident">get_param</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Subroutine to get parameters for current job</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_param(self):
    &#34;&#34;&#34;
    Subroutine to get parameters for current job
    &#34;&#34;&#34;

    param_file = self.project_name + &#39;_&#39; + Metadata.suffix_dict[self.job_type] + &#39;.yaml&#39;
    self.prmObj = prmMod.read_yaml(project_name=self.project_name,
                                   filename=param_file)
    self.params = self.prmObj.params</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Ot2Rec" href="index.html">Ot2Rec</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Ot2Rec.metadata.read_md_yaml" href="#Ot2Rec.metadata.read_md_yaml">read_md_yaml</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Ot2Rec.metadata.Metadata" href="#Ot2Rec.metadata.Metadata">Metadata</a></code></h4>
<ul class="">
<li><code><a title="Ot2Rec.metadata.Metadata.create_master_metadata" href="#Ot2Rec.metadata.Metadata.create_master_metadata">create_master_metadata</a></code></li>
<li><code><a title="Ot2Rec.metadata.Metadata.get_acquisition_settings" href="#Ot2Rec.metadata.Metadata.get_acquisition_settings">get_acquisition_settings</a></code></li>
<li><code><a title="Ot2Rec.metadata.Metadata.get_mc2_temp" href="#Ot2Rec.metadata.Metadata.get_mc2_temp">get_mc2_temp</a></code></li>
<li><code><a title="Ot2Rec.metadata.Metadata.get_num_frames" href="#Ot2Rec.metadata.Metadata.get_num_frames">get_num_frames</a></code></li>
<li><code><a title="Ot2Rec.metadata.Metadata.get_num_frames_parallel" href="#Ot2Rec.metadata.Metadata.get_num_frames_parallel">get_num_frames_parallel</a></code></li>
<li><code><a title="Ot2Rec.metadata.Metadata.get_param" href="#Ot2Rec.metadata.Metadata.get_param">get_param</a></code></li>
<li><code><a title="Ot2Rec.metadata.Metadata.get_ts_dose" href="#Ot2Rec.metadata.Metadata.get_ts_dose">get_ts_dose</a></code></li>
<li><code><a title="Ot2Rec.metadata.Metadata.suffix_dict" href="#Ot2Rec.metadata.Metadata.suffix_dict">suffix_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>