<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Ot2Rec.ctfsim API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Ot2Rec.ctfsim</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 Rosalind Franklin Institute
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the License for the specific
# language governing permissions and limitations under the License.


import re
import os
from glob import glob1
from functools import partial
import multiprocessing as mp

import pandas as pd
import numpy as np
import scipy.constants as spk
from scipy.signal import convolve2d as c2d
import skimage.transform as skt
from skimage.transform import iradon, iradon_sart
from tqdm import tqdm
import mrcfile


from icecream import ic

from . import user_args as uaMod
from . import magicgui as mgMod
from . import metadata as mdMod
from . import logger as logMod


def get_psf(ctffile, point_source_recip, k2_grid, alpha_g):
    &#34;&#34;&#34;
    Method to calculate PSF from CTFFIND4 outputs
    &#34;&#34;&#34;
    with open(ctffile, &#39;r&#39;) as f:
        lines = f.readlines()

    # Get system configs
    get_pixel = re.compile(&#39;^# Pixel&#39;)
    pixel_line = list(filter(get_pixel.match, lines))[0]
    w2 = float(pixel_line.split(&#39;;&#39;)[3].split()[2])
    cs = float(pixel_line.split(&#39;;&#39;)[2].split()[2]) * 1e-3
    voltage = float(pixel_line.split(&#39;;&#39;)[1].split()[2]) * 1e3

    get_def = re.compile(&#39;^[^#]&#39;)
    def_line = list(filter(get_def.match, lines))[0]
    df1 = float(def_line.split()[1]) * 1e-10
    df2 = float(def_line.split()[2]) * 1e-10
    alpha_ast = np.deg2rad(float(def_line.split()[3]))
    dphi = float(def_line.split()[4])

    # Calculate defocus df
    ddf = df1 - df2
    df = 0.5 * (df1 + df2 + ddf * np.cos(2 * (alpha_g - alpha_ast)))

    # Calculate beam wavelength
    hc = spk.h * spk.c
    denom = np.sqrt(voltage * spk.e * (2 * spk.m_e * spk.c**2 + voltage * spk.e))
    wvl = hc / denom

    # Calculate phase shift chi
    chi = np.pi * wvl * k2_grid * (df - 0.5 * wvl**2 * k2_grid * cs) + \
        (dphi + np.arctan2(w2, np.sqrt(1 - w2**2)))

    # Calculate CTF
    ctf = np.exp(-1j*chi)

    # Calculate first-zero of CTF
    denom0 = wvl * (cs/wvl)**0.25
    df_min = np.min(df) / np.sqrt(cs*wvl)
    df_max = np.max(df) / np.sqrt(cs*wvl)
    q_min = np.sqrt(-df_min + np.sqrt(df_min**2+2)) / denom0
    q_max = np.sqrt(-df_max + np.sqrt(df_max**2+2)) / denom0

    # FT point-source and convolve with CTF
    ps_ctf_k = point_source_recip * ctf

    return 1/q_min, 1/q_max, np.absolute(np.fft.ifft2(ps_ctf_k))


def calculate_k_grids(image_size, pixel_size):
    &#34;&#34;&#34;
    Method to calculate alpha_g (angle between g vector and horizontal axis) and norm2 on reciprocal grid

    Args:
        image_size (list): size of original image
        pixel_size (float): pixel size of original image

    Returns:
        ndarray, ndarray
    &#34;&#34;&#34;

    # Create k-space coordinate grid
    kx_gridpts = np.fft.fftfreq(image_size[0], d=pixel_size)
    ky_gridpts = np.fft.fftfreq(image_size[1], d=pixel_size)

    kxv, kyv = np.meshgrid(kx_gridpts, ky_gridpts, indexing=&#39;ij&#39;, sparse=True)
    k2_grid = kxv**2 + kyv**2

    alpha_g = np.angle(kxv + 1j*kyv)

    return k2_grid, alpha_g


def reconstruct_slice(args, slice_idx):
    stack, angle_list = args
    sino_slice = stack[..., slice_idx]
    return iradon(sino_slice.T, angle_list)


def reconstruct_full_stack(stack, angle_list):
    pool = mp.Pool(mp.cpu_count())
    p = partial(reconstruct_slice, (stack, angle_list))
    tomo_map = pool.map(p, range(stack.shape[2]))
    tomo = np.array(tomo_map, dtype=np.float32)

    return tomo


def normalise_stack(tomo, pixel_size):
    image_size = tomo.shape

    # Create k-space coordinate grid
    kx_gridpts = np.fft.fftfreq(image_size[0], d=pixel_size)
    ky_gridpts = np.fft.fftfreq(image_size[1], d=pixel_size)
    kz_gridpts = np.fft.fftfreq(image_size[2], d=pixel_size)

    # Fourier transform PSF stack
    ctf_stack = np.fft.fftn(tomo)

    # Normalise CTF stack and back FFT
    zero_freq = np.array([np.argmin(np.abs(kx_gridpts)),
                          np.argmin(np.abs(ky_gridpts)),
                          np.argmin(np.abs(kz_gridpts))])
    ctf_stack_norm = ctf_stack / ctf_stack[zero_freq[0], zero_freq[1], zero_freq[2]]
    psf_out = np.absolute(np.fft.ifftn(ctf_stack_norm))
    psf_out /= np.max(psf_out)

    return psf_out


def run():
    &#34;&#34;&#34;
    Method to run simulator for CTF from CTFFIND4 outputs
    &#34;&#34;&#34;
    logger = logMod.Logger(log_path=&#34;o2r_ctfsim.log&#34;)

    # Parse user inputs
    args = mgMod.get_args_ctfsim.show(run=True)

    project_name = args.project_name.value
    rootname = project_name
    if args.rootname.value != &#34;&#34;:
        while args.rootname.value.endswith(&#39;/&#39;):
            rootname = args.rootname.value[:-1]

    pixel_size = args.pixel_res.value * 1e-10
    ds_factor = args.ds_factor.value

    # Read in metadata from ctffind
    ctffind_md_file = project_name + &#39;_ctffind_mdout.yaml&#39;
    if not os.path.isfile(ctffind_md_file):
        logger(level=&#34;error&#34;,
               message=&#34;CTFFind metadata not found.&#34;)
        raise IOError(&#34;Error in Ot2Rec.ctfsim.run: ctffind metadata not found.&#34;)

    ctffind_obj = mdMod.read_md_yaml(project_name=project_name,
                                     job_type=&#39;ctfsim&#39;,
                                     filename=ctffind_md_file)
    ctffind_md = pd.DataFrame(ctffind_obj.metadata)

    # Read image to get dimensions
    sample_image = ctffind_md.iloc[0].file_paths
    with mrcfile.open(sample_image) as source:
        source_dim = skt.downscale_local_mean(source.data, (ds_factor, ds_factor)).shape

    # Generate point source
    ps = np.zeros(source_dim[-2:], dtype=np.float32)
    ps[ps.shape[0] // 2, ps.shape[1] // 2] = 1
    ps_k = np.fft.fft2(ps).astype(np.cdouble)

    # Calculate the grids in reciprocal space
    k2_grid, alpha_g_grid = calculate_k_grids(source_dim, pixel_size * ds_factor)

    # Grab tilt series numbers and tilt angles from metadata
    ts_list = sorted(pd.Series(ctffind_md[&#39;ts&#39;]).unique())

    logger(level=&#34;info&#34;,
           message=&#34;Ot2Rec-CTFSim started.&#34;)

    tqdm_iter = tqdm(ts_list, ncols=100)
    for curr_ts in tqdm_iter:
        # Create folders and subfolders
        subfolder_path = f&#39;{args.output_folder.value}/{rootname}_{curr_ts:04}&#39;
        os.makedirs(subfolder_path, exist_ok=True)

        # Find txt files from ctffind
        glob_list = glob1(&#39;./ctffind/&#39;, f&#39;{rootname}_{curr_ts:04}_*ctffind.txt&#39;)

        angle_list = [float(i.split(&#39;/&#39;)[-1].split(&#39;_&#39;)[2]) for i in glob_list]
        angle_index = [sorted(angle_list).index(i) for i in angle_list]

        full_ctf = np.empty(shape=(len(angle_list), *source_dim[-2:]),
                            dtype=np.float32)
        mean_res = np.empty(shape=(len(angle_list)),
                            dtype=np.float32)

        for index in range(len(angle_index)):
            res0, res1, full_ctf[angle_index[index], ...] = get_psf(ctffile=&#39;./ctffind/&#39; + glob_list[index],
                                                                    point_source_recip=ps_k,
                                                                    k2_grid=k2_grid,
                                                                    alpha_g=alpha_g_grid)
            mean_res[index] = 0.5*(res0+res1) * 1e10

        # calculate PSF
        (xmin, ymin, zmin) = (
            (source_dim[0] - args.dims.value[0]) // 2,
            (source_dim[0] - args.dims.value[1]) // 2,
            (source_dim[1] - args.dims.value[2]) // 2,
        )
        (xmax, ymax, zmax) = (xmin + args.dims.value[0], ymin + args.dims.value[1], zmin + args.dims.value[2])
        psf_unnorm = reconstruct_full_stack(full_ctf, sorted(angle_list))[xmin:xmax, ymin:ymax, zmin:zmax]

        full_psf = normalise_stack(psf_unnorm, pixel_size*ds_factor)

        # Write out psf stack
        with mrcfile.new(subfolder_path + f&#39;/{rootname}_{curr_ts:04}_PSF.mrc&#39;, overwrite=True) as f:
            f.set_data(np.asarray(full_psf, dtype=np.float32))

        # Write out rawtlt file
        with open(subfolder_path + f&#39;/{rootname}_{curr_ts:04}.tlt&#39;, &#39;w&#39;) as f:
            for angle in sorted(angle_list):
                f.writelines(str(angle) + &#39;\n&#39;)

        # Write out resolution file
        with open(subfolder_path + f&#39;/{rootname}_{curr_ts:04}.res&#39;, &#39;w&#39;) as f:
            np.savetxt(f, X=mean_res)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Ot2Rec.ctfsim.calculate_k_grids"><code class="name flex">
<span>def <span class="ident">calculate_k_grids</span></span>(<span>image_size, pixel_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to calculate alpha_g (angle between g vector and horizontal axis) and norm2 on reciprocal grid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image_size</code></strong> :&ensp;<code>list</code></dt>
<dd>size of original image</dd>
<dt><strong><code>pixel_size</code></strong> :&ensp;<code>float</code></dt>
<dd>pixel size of original image</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ndarray, ndarray</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_k_grids(image_size, pixel_size):
    &#34;&#34;&#34;
    Method to calculate alpha_g (angle between g vector and horizontal axis) and norm2 on reciprocal grid

    Args:
        image_size (list): size of original image
        pixel_size (float): pixel size of original image

    Returns:
        ndarray, ndarray
    &#34;&#34;&#34;

    # Create k-space coordinate grid
    kx_gridpts = np.fft.fftfreq(image_size[0], d=pixel_size)
    ky_gridpts = np.fft.fftfreq(image_size[1], d=pixel_size)

    kxv, kyv = np.meshgrid(kx_gridpts, ky_gridpts, indexing=&#39;ij&#39;, sparse=True)
    k2_grid = kxv**2 + kyv**2

    alpha_g = np.angle(kxv + 1j*kyv)

    return k2_grid, alpha_g</code></pre>
</details>
</dd>
<dt id="Ot2Rec.ctfsim.get_psf"><code class="name flex">
<span>def <span class="ident">get_psf</span></span>(<span>ctffile, point_source_recip, k2_grid, alpha_g)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to calculate PSF from CTFFIND4 outputs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_psf(ctffile, point_source_recip, k2_grid, alpha_g):
    &#34;&#34;&#34;
    Method to calculate PSF from CTFFIND4 outputs
    &#34;&#34;&#34;
    with open(ctffile, &#39;r&#39;) as f:
        lines = f.readlines()

    # Get system configs
    get_pixel = re.compile(&#39;^# Pixel&#39;)
    pixel_line = list(filter(get_pixel.match, lines))[0]
    w2 = float(pixel_line.split(&#39;;&#39;)[3].split()[2])
    cs = float(pixel_line.split(&#39;;&#39;)[2].split()[2]) * 1e-3
    voltage = float(pixel_line.split(&#39;;&#39;)[1].split()[2]) * 1e3

    get_def = re.compile(&#39;^[^#]&#39;)
    def_line = list(filter(get_def.match, lines))[0]
    df1 = float(def_line.split()[1]) * 1e-10
    df2 = float(def_line.split()[2]) * 1e-10
    alpha_ast = np.deg2rad(float(def_line.split()[3]))
    dphi = float(def_line.split()[4])

    # Calculate defocus df
    ddf = df1 - df2
    df = 0.5 * (df1 + df2 + ddf * np.cos(2 * (alpha_g - alpha_ast)))

    # Calculate beam wavelength
    hc = spk.h * spk.c
    denom = np.sqrt(voltage * spk.e * (2 * spk.m_e * spk.c**2 + voltage * spk.e))
    wvl = hc / denom

    # Calculate phase shift chi
    chi = np.pi * wvl * k2_grid * (df - 0.5 * wvl**2 * k2_grid * cs) + \
        (dphi + np.arctan2(w2, np.sqrt(1 - w2**2)))

    # Calculate CTF
    ctf = np.exp(-1j*chi)

    # Calculate first-zero of CTF
    denom0 = wvl * (cs/wvl)**0.25
    df_min = np.min(df) / np.sqrt(cs*wvl)
    df_max = np.max(df) / np.sqrt(cs*wvl)
    q_min = np.sqrt(-df_min + np.sqrt(df_min**2+2)) / denom0
    q_max = np.sqrt(-df_max + np.sqrt(df_max**2+2)) / denom0

    # FT point-source and convolve with CTF
    ps_ctf_k = point_source_recip * ctf

    return 1/q_min, 1/q_max, np.absolute(np.fft.ifft2(ps_ctf_k))</code></pre>
</details>
</dd>
<dt id="Ot2Rec.ctfsim.normalise_stack"><code class="name flex">
<span>def <span class="ident">normalise_stack</span></span>(<span>tomo, pixel_size)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalise_stack(tomo, pixel_size):
    image_size = tomo.shape

    # Create k-space coordinate grid
    kx_gridpts = np.fft.fftfreq(image_size[0], d=pixel_size)
    ky_gridpts = np.fft.fftfreq(image_size[1], d=pixel_size)
    kz_gridpts = np.fft.fftfreq(image_size[2], d=pixel_size)

    # Fourier transform PSF stack
    ctf_stack = np.fft.fftn(tomo)

    # Normalise CTF stack and back FFT
    zero_freq = np.array([np.argmin(np.abs(kx_gridpts)),
                          np.argmin(np.abs(ky_gridpts)),
                          np.argmin(np.abs(kz_gridpts))])
    ctf_stack_norm = ctf_stack / ctf_stack[zero_freq[0], zero_freq[1], zero_freq[2]]
    psf_out = np.absolute(np.fft.ifftn(ctf_stack_norm))
    psf_out /= np.max(psf_out)

    return psf_out</code></pre>
</details>
</dd>
<dt id="Ot2Rec.ctfsim.reconstruct_full_stack"><code class="name flex">
<span>def <span class="ident">reconstruct_full_stack</span></span>(<span>stack, angle_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstruct_full_stack(stack, angle_list):
    pool = mp.Pool(mp.cpu_count())
    p = partial(reconstruct_slice, (stack, angle_list))
    tomo_map = pool.map(p, range(stack.shape[2]))
    tomo = np.array(tomo_map, dtype=np.float32)

    return tomo</code></pre>
</details>
</dd>
<dt id="Ot2Rec.ctfsim.reconstruct_slice"><code class="name flex">
<span>def <span class="ident">reconstruct_slice</span></span>(<span>args, slice_idx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstruct_slice(args, slice_idx):
    stack, angle_list = args
    sino_slice = stack[..., slice_idx]
    return iradon(sino_slice.T, angle_list)</code></pre>
</details>
</dd>
<dt id="Ot2Rec.ctfsim.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to run simulator for CTF from CTFFIND4 outputs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run():
    &#34;&#34;&#34;
    Method to run simulator for CTF from CTFFIND4 outputs
    &#34;&#34;&#34;
    logger = logMod.Logger(log_path=&#34;o2r_ctfsim.log&#34;)

    # Parse user inputs
    args = mgMod.get_args_ctfsim.show(run=True)

    project_name = args.project_name.value
    rootname = project_name
    if args.rootname.value != &#34;&#34;:
        while args.rootname.value.endswith(&#39;/&#39;):
            rootname = args.rootname.value[:-1]

    pixel_size = args.pixel_res.value * 1e-10
    ds_factor = args.ds_factor.value

    # Read in metadata from ctffind
    ctffind_md_file = project_name + &#39;_ctffind_mdout.yaml&#39;
    if not os.path.isfile(ctffind_md_file):
        logger(level=&#34;error&#34;,
               message=&#34;CTFFind metadata not found.&#34;)
        raise IOError(&#34;Error in Ot2Rec.ctfsim.run: ctffind metadata not found.&#34;)

    ctffind_obj = mdMod.read_md_yaml(project_name=project_name,
                                     job_type=&#39;ctfsim&#39;,
                                     filename=ctffind_md_file)
    ctffind_md = pd.DataFrame(ctffind_obj.metadata)

    # Read image to get dimensions
    sample_image = ctffind_md.iloc[0].file_paths
    with mrcfile.open(sample_image) as source:
        source_dim = skt.downscale_local_mean(source.data, (ds_factor, ds_factor)).shape

    # Generate point source
    ps = np.zeros(source_dim[-2:], dtype=np.float32)
    ps[ps.shape[0] // 2, ps.shape[1] // 2] = 1
    ps_k = np.fft.fft2(ps).astype(np.cdouble)

    # Calculate the grids in reciprocal space
    k2_grid, alpha_g_grid = calculate_k_grids(source_dim, pixel_size * ds_factor)

    # Grab tilt series numbers and tilt angles from metadata
    ts_list = sorted(pd.Series(ctffind_md[&#39;ts&#39;]).unique())

    logger(level=&#34;info&#34;,
           message=&#34;Ot2Rec-CTFSim started.&#34;)

    tqdm_iter = tqdm(ts_list, ncols=100)
    for curr_ts in tqdm_iter:
        # Create folders and subfolders
        subfolder_path = f&#39;{args.output_folder.value}/{rootname}_{curr_ts:04}&#39;
        os.makedirs(subfolder_path, exist_ok=True)

        # Find txt files from ctffind
        glob_list = glob1(&#39;./ctffind/&#39;, f&#39;{rootname}_{curr_ts:04}_*ctffind.txt&#39;)

        angle_list = [float(i.split(&#39;/&#39;)[-1].split(&#39;_&#39;)[2]) for i in glob_list]
        angle_index = [sorted(angle_list).index(i) for i in angle_list]

        full_ctf = np.empty(shape=(len(angle_list), *source_dim[-2:]),
                            dtype=np.float32)
        mean_res = np.empty(shape=(len(angle_list)),
                            dtype=np.float32)

        for index in range(len(angle_index)):
            res0, res1, full_ctf[angle_index[index], ...] = get_psf(ctffile=&#39;./ctffind/&#39; + glob_list[index],
                                                                    point_source_recip=ps_k,
                                                                    k2_grid=k2_grid,
                                                                    alpha_g=alpha_g_grid)
            mean_res[index] = 0.5*(res0+res1) * 1e10

        # calculate PSF
        (xmin, ymin, zmin) = (
            (source_dim[0] - args.dims.value[0]) // 2,
            (source_dim[0] - args.dims.value[1]) // 2,
            (source_dim[1] - args.dims.value[2]) // 2,
        )
        (xmax, ymax, zmax) = (xmin + args.dims.value[0], ymin + args.dims.value[1], zmin + args.dims.value[2])
        psf_unnorm = reconstruct_full_stack(full_ctf, sorted(angle_list))[xmin:xmax, ymin:ymax, zmin:zmax]

        full_psf = normalise_stack(psf_unnorm, pixel_size*ds_factor)

        # Write out psf stack
        with mrcfile.new(subfolder_path + f&#39;/{rootname}_{curr_ts:04}_PSF.mrc&#39;, overwrite=True) as f:
            f.set_data(np.asarray(full_psf, dtype=np.float32))

        # Write out rawtlt file
        with open(subfolder_path + f&#39;/{rootname}_{curr_ts:04}.tlt&#39;, &#39;w&#39;) as f:
            for angle in sorted(angle_list):
                f.writelines(str(angle) + &#39;\n&#39;)

        # Write out resolution file
        with open(subfolder_path + f&#39;/{rootname}_{curr_ts:04}.res&#39;, &#39;w&#39;) as f:
            np.savetxt(f, X=mean_res)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Ot2Rec" href="index.html">Ot2Rec</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Ot2Rec.ctfsim.calculate_k_grids" href="#Ot2Rec.ctfsim.calculate_k_grids">calculate_k_grids</a></code></li>
<li><code><a title="Ot2Rec.ctfsim.get_psf" href="#Ot2Rec.ctfsim.get_psf">get_psf</a></code></li>
<li><code><a title="Ot2Rec.ctfsim.normalise_stack" href="#Ot2Rec.ctfsim.normalise_stack">normalise_stack</a></code></li>
<li><code><a title="Ot2Rec.ctfsim.reconstruct_full_stack" href="#Ot2Rec.ctfsim.reconstruct_full_stack">reconstruct_full_stack</a></code></li>
<li><code><a title="Ot2Rec.ctfsim.reconstruct_slice" href="#Ot2Rec.ctfsim.reconstruct_slice">reconstruct_slice</a></code></li>
<li><code><a title="Ot2Rec.ctfsim.run" href="#Ot2Rec.ctfsim.run">run</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>