<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Ot2Rec.aretomo API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Ot2Rec.aretomo</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 Rosalind Franklin Institute
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the License for the specific
# language governing permissions and limitations under the License.


import argparse
import os
import shutil
import subprocess
import warnings
from glob import glob
from pathlib import Path

import yaml
from icecream import ic
from tqdm import tqdm

from . import align
from . import logger as logMod
from . import magicgui as mgMod
from . import params as prmMod
from . import user_args as uaMod


class AreTomo:
    &#34;&#34;&#34;
    Class encapsulating a AreTomo object
    &#34;&#34;&#34;

    def __init__(self,
                 project_name,
                 params_in,
                 logger_in,
                 ):
        &#34;&#34;&#34;
        Initialising a AreTomo object

        Args:
            project_name (str): name of current project
            params_in (Params): parameters for stack creation
            logger_in (Logger): logger object to keep record of progress and errors
        &#34;&#34;&#34;

        self.proj_name = project_name

        self.pObj = params_in
        self.params = self.pObj.params

        self.logObj = logger_in

        self.md_out = {}

        self.sta = {}

        self._get_internal_metadata()

    def _get_internal_metadata(self):
        &#34;&#34;&#34;
        Method to prepare internal metadata for processing and checking
        &#34;&#34;&#34;
        self.basis_folder = self.params[&#39;System&#39;][&#39;output_path&#39;]
        if self.basis_folder.endswith(&#39;/&#39;):
            self.basis_folder = self.basis_folder[:-1]

        self.rootname = self.params[&#39;System&#39;][&#39;output_rootname&#39;]
        if self.rootname.endswith(&#39;_&#39;):
            self.rootname = self.rootname[:-1]

        self.suffix = self.params[&#39;System&#39;][&#39;output_suffix&#39;]
        if self.suffix.endswith(&#39;_&#39;):
            self.suffix = self.suffix[:-1]

        # Create the folders and dictionary for future reference
        self._path_dict = {}
        self.md_out[&#34;process_list&#34;] = dict(zip(range(1, len(self.params[&#39;System&#39;][&#39;process_list&#39;])+1),
                                               self.params[&#39;System&#39;][&#39;process_list&#39;]))
        for curr_ts in self.params[&#39;System&#39;][&#39;process_list&#39;]:
            subfolder = (f&#34;{self.basis_folder}/&#34;
                         f&#34;{self.rootname}_{curr_ts:04d}{self.suffix}&#34;)
            os.makedirs(subfolder, exist_ok=True)
            # self._path_dict[curr_ts] = subfolder
            if &#34;aretomo_output_dir&#34; not in list(self.md_out.keys()):
                self.md_out[&#34;aretomo_output_dir&#34;] = {}
                self.md_out[&#34;aretomo_align_stats&#34;] = {}
            self.md_out[&#34;aretomo_output_dir&#34;][curr_ts] = subfolder
            self.md_out[&#34;aretomo_align_stats&#34;][curr_ts] = (
                f&#34;{subfolder}/&#34;
                f&#34;{self.rootname}_{curr_ts:04d}{self.suffix}.st.aln&#34;
            )

        if self.params[&#34;AreTomo_setup&#34;][&#34;out_imod&#34;] != &#34;N/A&#34;:
            self.sta_folder = f&#34;{self.basis_folder}/STA&#34;
            self.md_out[&#34;aretomo_STA_dir&#34;] = self.sta_folder
            os.makedirs(self.sta_folder, exist_ok=True)

    def _get_aretomo_align_command(self, i):
        &#34;&#34;&#34;
        Method to get command to set up AreTomo align

        Args:
            i (int): The i-th tilt series to process
        &#34;&#34;&#34;
        cmd = [
            &#39;AreTomo&#39;,
            &#39;-InMrc&#39;,
            self.params[&#39;AreTomo_setup&#39;][&#39;input_mrc&#39;][i],
            &#39;-OutMrc&#39;,
            self.params[&#39;AreTomo_setup&#39;][&#39;output_mrc&#39;][i],
            &#39;-AngFile&#39;,
            self.params[&#39;AreTomo_setup&#39;][&#39;tilt_angles&#39;][i],
            &#39;-VolZ&#39;,
            &#39;0&#39;,
            &#39;-OutBin&#39;,
            str(self.params[&#39;AreTomo_setup&#39;][&#39;output_binning&#39;]),
        ]

        # Specify path to AreTomo if not using module loaded version
        if len(self.params[&#39;System&#39;][&#39;aretomo_path&#39;]) &gt; 0:
            cmd[0] = self.params[&#39;System&#39;][&#39;aretomo_path&#39;]

        return cmd

    def _get_aretomo_recon_command(self, i):
        &#34;&#34;&#34;
        Method to get command to set up AreTomo reconstruction

        Args:
            i (int): The i-th tilt series to process
        &#34;&#34;&#34;
        cmd = [
            &#39;AreTomo&#39;,
            &#39;-InMrc&#39;,
            self.params[&#39;AreTomo_setup&#39;][&#39;input_mrc&#39;][i],
            &#39;-OutMrc&#39;,
            self.params[&#39;AreTomo_setup&#39;][&#39;output_mrc&#39;][i],
            &#39;-AngFile&#39;,
            self.params[&#39;AreTomo_setup&#39;][&#39;tilt_angles&#39;][i],
            &#39;-VolZ&#39;,
            str(self.params[&#39;AreTomo_recon&#39;][&#39;volz&#39;]),
            &#39;-OutBin&#39;,
            str(self.params[&#39;AreTomo_setup&#39;][&#39;output_binning&#39;]),
        ]

        if self.params[&#39;AreTomo_setup&#39;][&#39;aretomo_mode&#39;] == 1:
            cmd.append(&#39;-Align&#39;)
            cmd.append(&#39;0&#39;)
        
        if self.params[&#39;AreTomo_recon&#39;][&#39;recon_algo&#39;] == &#34;WBP&#34;:
            # WBP
            cmd.append(&#39;-Wbp&#39;)
            cmd.append(&#39;1&#39;)

        # Specify path to AreTomo if not using module loaded version
        if len(self.params[&#39;System&#39;][&#39;aretomo_path&#39;]) &gt; 0:
            cmd[0] = self.params[&#39;System&#39;][&#39;aretomo_path&#39;]

        return cmd

    def _run_aretomo(self, i):
        &#34;&#34;&#34;
        Method to run AreTomo workflows
        &#34;&#34;&#34;
        curr_ts = self.params[&#39;System&#39;][&#39;process_list&#39;][i]

        # check AreTomo mode
        if self.params[&#39;AreTomo_setup&#39;][&#39;aretomo_mode&#39;] == 0:
            align_cmd = self._get_aretomo_align_command(i)
            cmd = align_cmd
        else:
            recon_cmd = self._get_aretomo_recon_command(i)
            cmd = recon_cmd

        out_imod = self.params[&#39;AreTomo_setup&#39;][&#39;out_imod&#39;]
        if out_imod != &#34;N/A&#34;:
            outimod_lookup = {
                &#34;RELION4&#34;: &#34;1&#34;,
                &#34;Warp&#34;: &#34;2&#34;,
                &#34;Local alignment&#34;: &#34;3&#34;,
            }
            cmd.append(&#39;-OutImod&#39;)
            cmd.append(outimod_lookup[out_imod])
        
        # Add darktol
        if self.params[&#39;AreTomo_setup&#39;][&#39;aretomo_mode&#39;] != 1:
            cmd.append(&#34;-DarkTol&#34;)
            cmd.append(str(self.params[&#39;AreTomo_setup&#39;][&#39;dark_tol&#39;]))

        # Add extra kwargs
        kwargs = self.params[&#34;AreTomo_kwargs&#34;].keys()
        for kwarg in kwargs:
            cmd.append(kwarg)
            cmd.append(self.params[&#34;AreTomo_kwargs&#34;][kwarg])

        # Add AreTomo command and out_mrc to md_out
        if &#34;aretomo_cmd&#34; not in list(self.md_out.keys()):
            self.md_out[&#34;aretomo_cmd&#34;] = {}
        self.md_out[&#34;aretomo_cmd&#34;][curr_ts] = &#34; &#34;.join(cmd)

        # Run aretomo
        aretomo_run = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            encoding=&#39;ascii&#39;,
            check=True,
        )

        # If STA files are generated save folder names to move to common folder
        if self.params[&#34;AreTomo_setup&#34;][&#34;out_imod&#34;] != &#34;N/A&#34;:
            output_mrc = self.params[&#34;AreTomo_setup&#34;][&#34;output_mrc&#34;][i]
            self.sta[curr_ts] = (
                f&#39;{self.basis_folder}/&#39;
                f&#39;{self.rootname}_{curr_ts:04d}{self.suffix}/&#39;
                f&#39;{os.path.splitext(os.path.basename(output_mrc))[0]}_Imod/&#39;
            )

        self.logObj(f&#34;\nStdOut:{aretomo_run.stdout}\n&#34;)
        self.logObj(f&#34;\nStdErr:{aretomo_run.stderr}\n&#34;)

    def run_aretomo_all(self):
        &#34;&#34;&#34;
        Method to run AreTomo for all ts in process list
        &#34;&#34;&#34;
        ts_list = self.params[&#39;System&#39;][&#39;process_list&#39;]
        tqdm_iter = tqdm(ts_list, ncols=100)
        for i, curr_ts in enumerate(tqdm_iter):
            tqdm_iter.set_description(f&#34;Processing TS {curr_ts}...&#34;)
            self._run_aretomo(i)
        self.export_metadata()

    def export_metadata(self):
        &#34;&#34;&#34;
        Method to export metadata as yaml
        &#34;&#34;&#34;
        # If STA files created, move to common folder
        if self.params[&#34;AreTomo_setup&#34;][&#34;out_imod&#34;] != &#34;N/A&#34;: 
            for ts in list(self.sta.keys()):
                sta_ts_folder = (
                    f&#34;{self.sta_folder}/{self.sta[ts].split(os.sep)[-2]}&#34;
                )
                if os.path.exists(sta_ts_folder):
                    self.logObj(
                        f&#34;STA folder {sta_ts_folder} not empty, overwriting.&#34;
                    )
                    shutil.rmtree(sta_ts_folder)
                shutil.move(
                    src=self.sta[ts],
                    dst=self.sta_folder,
                )

        yaml_file = self.proj_name + &#34;_aretomo_mdout.yaml&#34;

        with open(yaml_file, &#39;w&#39;) as f:
            yaml.dump(self.md_out, f, indent=4, sort_keys=False)


# Plugin functions

def _update_volz(args, aretomo_params):
    # for workflows with reconstruction, set VolZ unless already overwritten
    args[&#34;volz&#34;] = int(args[&#34;volz&#34;])
    if args[&#34;aretomo_mode&#34;] &gt; 0:
        if args[&#34;volz&#34;] == -1:
            if (args[&#34;sample_thickness&#34;] &lt;= 0) or (args[&#34;pixel_size&#34;] &lt;= 0):
                raise ValueError(
                    f&#34;Please set sample thickness and pixel size \
                    in nm to automatically calculate VolZ. Currently sample_thickness \
                    = {args[&#39;sample_thickness&#39;]} and pixel_size = {args[&#39;pixel_size&#39;]}&#34;)
            aretomo_params.params[&#34;AreTomo_recon&#34;][&#34;volz&#34;] = int(
                (args[&#34;sample_thickness&#34;] * args[&#34;pixel_size&#34;] * 0.1) + 200   # factor of 0.1 because pixel_size in A
            )

    # Reject volz and sample thickness values which are not -1 or &gt;0
        elif (args[&#34;volz&#34;] == 0) or (args[&#34;volz&#34;] &lt; -1):
            raise ValueError(
                &#34;VolZ should be at least 1, unless sample thickness and pixel size are set&#34;
            )


def _create_stacks_with_imod(args):
    # Uses align to create the InMrc and AngFile in correct form
        try:
            args_in_align = mgMod.get_args_align
            args_in_align.project_name.value = args[&#34;project_name&#34;]
            args_in_align.rot_angle.value = args[&#34;rot_angle&#34;]
            args_in_align.output_folder.value = args[&#34;output_path&#34;]
            align.create_yaml(args_in=args_in_align)
            align.run(
                newstack=True,
                do_align=False,
                args_pass=[args[&#34;project_name&#34;]])
            print(&#34;Created stacks for input to AreTomo&#34;)
        except:
            warnings.warn(&#34;Stacks could not be created, IMOD might not be loaded&#34;)


def _find_files_with_ext(ext, rootname, suffix, directory):
    search_term = (f&#34;{directory}/{rootname}_*{suffix}/&#34;
                   f&#34;{rootname}_*{suffix}{ext}&#34;)
    file_list = glob(search_term)
    file_list.sort()

    if len(file_list) == 0:
        warnings.warn(
            f&#34;Files matching {search_term} were not found&#34;)

    return file_list


def _get_yaml_filename(aretomo_mode, project_name):
    aretomo_yaml_names = {
        0: f&#34;{project_name}_aretomo_align.yaml&#34;,
        1: f&#34;{project_name}_aretomo_recon.yaml&#34;,
        2: f&#34;{project_name}_aretomo_align-recon.yaml&#34;
    }
    return aretomo_yaml_names[aretomo_mode]


def _get_process_list(file_list, rootname, suffix, ext):
    ts_list = []
    for st in file_list:
        st_bn = os.path.basename(st)
        if suffix != &#34;&#34;:
            ts_list.append(
                int(st_bn.split(f&#34;{rootname}_&#34;)[1].split(f&#34;_{suffix}{ext}&#34;)[0])
            )
        else:
            ts_list.append(
                int(st_bn.split(f&#34;{rootname}_&#34;)[1].split(ext)[0])
            )
    return ts_list


def update_yaml(args):
    &#34;&#34;&#34;
    Method to update yaml file for AreTomo

    Args:
        args (Namespace): Namespace containing user inputs
        kwargs (list): List of extra inputs, used for extra AreTomo arguments
                     beyond those implemented here
    &#34;&#34;&#34;
    # Read in YAML, set mundane things
    if args[&#34;rootname&#34;] == &#34;&#34;:
        rootname = args[&#34;project_name&#34;]
    else:
        rootname = args[&#34;rootname&#34;]
    suffix = args[&#34;suffix&#34;]

    aretomo_yaml_name = _get_yaml_filename(
        args[&#34;aretomo_mode&#34;],
        args[&#34;project_name&#34;]
    )

    aretomo_params = prmMod.read_yaml(
        project_name=args[&#34;project_name&#34;],
        filename=aretomo_yaml_name
    )

    # Check that AreTomo Mode is 0-3
    if (args[&#34;aretomo_mode&#34;] &lt; 0) or (args[&#34;aretomo_mode&#34;] &gt; 2):
        raise ValueError(&#34;AreTomo mode must be 0, 1, 2&#34;)

    # Add optional kwargs TODO: Implement
    # aretomo_params.params[&#39;AreTomo_kwargs&#39;] = kwargs

    if args[&#34;aretomo_mode&#34;] != 1:  # for workflows with alignment
        # Set InMrc
        st_file_list = _find_files_with_ext(
            args[&#34;input_ext&#34;],
            rootname,
            suffix,
            str(args[&#34;input_mrc_folder&#34;])
        )

        if len(st_file_list) == 0:  # assume that input_mrc_folder is from motioncor
            # Create input stacks from motioncor images
            _create_stacks_with_imod(args)
            st_file_list = _find_files_with_ext(
                &#34;.st&#34;,
                rootname,
                suffix,
                str(args[&#34;output_path&#34;])
            )

        aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;input_mrc&#34;] = st_file_list

        # Set AngFile
        if args[&#34;tilt_angles&#34;] == &#34;&#34;:
            tlt_file_list = _find_files_with_ext(
                &#34;.rawtlt&#34;,
                rootname,
                suffix,
                str(args[&#34;input_mrc_folder&#34;])
            )
            if len(tlt_file_list) == 0: # assume that input_mrc_folder is from motioncor
                tlt_file_list = _find_files_with_ext(
                    &#34;.rawtlt&#34;,
                    rootname,
                    suffix,
                    str(args[&#34;output_path&#34;])
                )
        else:
            tlt_file_list = args[&#34;tilt_angles&#34;]

        aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;tilt_angles&#34;] = tlt_file_list

        # Set process list
        ts_list = _get_process_list(
            st_file_list,
            rootname,
            suffix,
            args[&#34;input_ext&#34;]
        )
        aretomo_params.params[&#34;System&#34;][&#34;process_list&#34;] = ts_list

        # Set output mrc
        output_lookup = {0: &#34;_ali.mrc&#34;, 2: &#34;_rec.mrc&#34;}
        # out_file_list = [
        #     (f&#34;{aretomo_params.params[&#39;System&#39;][&#39;output_path&#39;]}/&#34;
        #      f&#34;{os.path.splitext(os.path.basename(file))[0]}/&#34;
        #      f&#34;{os.path.splitext(os.path.basename(file))[0]}&#34;
        #      f&#34;{output_lookup[args[&#39;aretomo_mode&#39;]]}&#34;) for file in st_file_list
        # ]

        rootname = aretomo_params.params[&#39;System&#39;][&#39;output_rootname&#39;]
        suffix = aretomo_params.params[&#39;System&#39;][&#39;output_suffix&#39;]
        ext = output_lookup[args[&#39;aretomo_mode&#39;]]
        out_file_list = [
            (f&#34;{aretomo_params.params[&#39;System&#39;][&#39;output_path&#39;]}/&#34;
             f&#34;{rootname}_{curr_ts:04d}{suffix}/&#34;
             f&#34;{rootname}_{curr_ts:04d}{suffix}{ext}&#34;
            ) for curr_ts in ts_list
        ]

        aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;output_mrc&#34;] = out_file_list

    elif args[&#34;aretomo_mode&#34;] == 1: # for reconstruction only
        # Set InMrc
        st_file_list = _find_files_with_ext(
            &#34;_ali.mrc&#34;,
            rootname,
            suffix,
            str(args[&#34;input_mrc_folder&#34;])
        )
        aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;input_mrc&#34;] = st_file_list

        # Set AngFile
        if args[&#34;tilt_angles&#34;] == &#34;&#34;:
            # NOTE: sometimes if .fid.tlt files are present these are accidentally found too.
            # Temp fix
            # tlt_file_list = _find_files_with_ext(
            #     &#34;.tlt&#34;,
            #     rootname,
            #     suffix,
            #     str(args[&#34;input_mrc_folder&#34;])
            # )
            tlt_file_list = [f&#34;{f.strip(&#39;_ali.mrc&#39;)}.tlt&#34; for f in st_file_list]

            aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;tilt_angles&#34;] = tlt_file_list
        else:
            tlt_file_list = args[&#34;tilt_angles&#34;]
        aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;tilt_angles&#34;] = tlt_file_list

        # Set process list
        ts_list = _get_process_list(st_file_list, rootname, suffix, &#34;_ali.mrc&#34;)
        aretomo_params.params[&#34;System&#34;][&#34;process_list&#34;] = ts_list

        # Set output mrc
        out_file_list = [
            (f&#34;{aretomo_params.params[&#39;System&#39;][&#39;output_path&#39;]}/&#34;
             f&#34;{os.path.splitext(os.path.basename(file))[0].strip(&#39;_ali&#39;)}/&#34;
             f&#34;{os.path.splitext(os.path.basename(file))[0]}&#34;
             f&#34;_rec.mrc&#34;) for file in st_file_list
        ]
        aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;output_mrc&#34;] = out_file_list

    # Add the rest of the argparse values to aretomo_params
    aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;aretomo_mode&#34;] = args[&#34;aretomo_mode&#34;]
    aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;output_binning&#34;] = args[&#34;output_binning&#34;]
    aretomo_params.params[&#34;AreTomo_recon&#34;][&#34;volz&#34;] = args[&#34;volz&#34;]
    aretomo_params.params[&#34;AreTomo_recon&#34;][&#34;sample_thickness&#34;] = args[&#34;sample_thickness&#34;]
    aretomo_params.params[&#34;AreTomo_recon&#34;][&#34;pixel_size&#34;] = args[&#34;pixel_size&#34;]
    aretomo_params.params[&#34;AreTomo_recon&#34;][&#34;recon_algo&#34;] = args[&#34;recon_algo&#34;]

    _update_volz(args, aretomo_params)

    # update and write yaml file
    with open(Path(aretomo_yaml_name), &#34;w&#34;) as f:
        yaml.dump(aretomo_params.params, f, indent=4, sort_keys=False)


def create_yaml(input_mgNS=None):
    &#34;&#34;&#34;
    Subroutine to create new yaml file for AreTomo
    &#34;&#34;&#34;

    # Parse user inputs
    if input_mgNS is None:
        args = mgMod.get_args_aretomo.show(run=True).asdict()
    else:
        args = input_mgNS

    # Create the yaml file, then automatically update it
    prmMod.new_aretomo_yaml(args)
    update_yaml(args)


def run():
    &#34;&#34;&#34;
    Method to run AreTomo
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser()
    parser.add_argument(&#34;project_name&#34;,
                        type=str,
                        help=&#34;Name of current project&#34;)
    parser.add_argument(&#34;aretomo_mode&#34;,
                        type=int,
                        help=&#34;Processes to be run in AreTomo, must be set.&#34;
                        &#34; 0: alignment only,&#34;
                        &#34; 1: reconstruction only,&#34;
                        &#34; 2: alignment + reconstruction&#34;
                        )
    args = parser.parse_args()

    # Check if prerequisite files exist
    aretomo_yaml_names = {0: args.project_name + &#34;_aretomo_align.yaml&#34;,
                          1: args.project_name + &#34;_aretomo_recon.yaml&#34;,
                          2: args.project_name + &#34;_aretomo_align-recon.yaml&#34;}

    aretomo_yaml_name = aretomo_yaml_names[int(args.aretomo_mode)]
    if not os.path.isfile(aretomo_yaml_name):
        raise IOError(&#34;Error in Ot2Rec.main.run_aretomo: AreTomo yaml file not found.&#34;)

    # Read in config and metadata
    aretomo_config = prmMod.read_yaml(
        project_name=args.project_name,
        filename=aretomo_yaml_name
    )

    # Create Logger object
    aretomo_log_names = {0: &#34;o2r_aretomo_align.log&#34;,
                         1: &#34;o2r_aretomo_recon.log&#34;,
                         2: &#34;o2r_aretomo_align-recon.log&#34;}
    log_path = aretomo_log_names[int(args.aretomo_mode)]
    try:
        os.remove(log_path)
    except:
        pass
    logger = logMod.Logger(log_path=log_path)

    # Create AreTomo object
    aretomo_obj = AreTomo(
        project_name=args.project_name,
        params_in=aretomo_config,
        logger_in=logger
    )

    # Run AreTomo commands
    aretomo_obj.run_aretomo_all()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Ot2Rec.aretomo.create_yaml"><code class="name flex">
<span>def <span class="ident">create_yaml</span></span>(<span>input_mgNS=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Subroutine to create new yaml file for AreTomo</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_yaml(input_mgNS=None):
    &#34;&#34;&#34;
    Subroutine to create new yaml file for AreTomo
    &#34;&#34;&#34;

    # Parse user inputs
    if input_mgNS is None:
        args = mgMod.get_args_aretomo.show(run=True).asdict()
    else:
        args = input_mgNS

    # Create the yaml file, then automatically update it
    prmMod.new_aretomo_yaml(args)
    update_yaml(args)</code></pre>
</details>
</dd>
<dt id="Ot2Rec.aretomo.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to run AreTomo</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run():
    &#34;&#34;&#34;
    Method to run AreTomo
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser()
    parser.add_argument(&#34;project_name&#34;,
                        type=str,
                        help=&#34;Name of current project&#34;)
    parser.add_argument(&#34;aretomo_mode&#34;,
                        type=int,
                        help=&#34;Processes to be run in AreTomo, must be set.&#34;
                        &#34; 0: alignment only,&#34;
                        &#34; 1: reconstruction only,&#34;
                        &#34; 2: alignment + reconstruction&#34;
                        )
    args = parser.parse_args()

    # Check if prerequisite files exist
    aretomo_yaml_names = {0: args.project_name + &#34;_aretomo_align.yaml&#34;,
                          1: args.project_name + &#34;_aretomo_recon.yaml&#34;,
                          2: args.project_name + &#34;_aretomo_align-recon.yaml&#34;}

    aretomo_yaml_name = aretomo_yaml_names[int(args.aretomo_mode)]
    if not os.path.isfile(aretomo_yaml_name):
        raise IOError(&#34;Error in Ot2Rec.main.run_aretomo: AreTomo yaml file not found.&#34;)

    # Read in config and metadata
    aretomo_config = prmMod.read_yaml(
        project_name=args.project_name,
        filename=aretomo_yaml_name
    )

    # Create Logger object
    aretomo_log_names = {0: &#34;o2r_aretomo_align.log&#34;,
                         1: &#34;o2r_aretomo_recon.log&#34;,
                         2: &#34;o2r_aretomo_align-recon.log&#34;}
    log_path = aretomo_log_names[int(args.aretomo_mode)]
    try:
        os.remove(log_path)
    except:
        pass
    logger = logMod.Logger(log_path=log_path)

    # Create AreTomo object
    aretomo_obj = AreTomo(
        project_name=args.project_name,
        params_in=aretomo_config,
        logger_in=logger
    )

    # Run AreTomo commands
    aretomo_obj.run_aretomo_all()</code></pre>
</details>
</dd>
<dt id="Ot2Rec.aretomo.update_yaml"><code class="name flex">
<span>def <span class="ident">update_yaml</span></span>(<span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to update yaml file for AreTomo</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong> :&ensp;<code>Namespace</code></dt>
<dd>Namespace containing user inputs</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>list</code></dt>
<dd>List of extra inputs, used for extra AreTomo arguments
beyond those implemented here</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_yaml(args):
    &#34;&#34;&#34;
    Method to update yaml file for AreTomo

    Args:
        args (Namespace): Namespace containing user inputs
        kwargs (list): List of extra inputs, used for extra AreTomo arguments
                     beyond those implemented here
    &#34;&#34;&#34;
    # Read in YAML, set mundane things
    if args[&#34;rootname&#34;] == &#34;&#34;:
        rootname = args[&#34;project_name&#34;]
    else:
        rootname = args[&#34;rootname&#34;]
    suffix = args[&#34;suffix&#34;]

    aretomo_yaml_name = _get_yaml_filename(
        args[&#34;aretomo_mode&#34;],
        args[&#34;project_name&#34;]
    )

    aretomo_params = prmMod.read_yaml(
        project_name=args[&#34;project_name&#34;],
        filename=aretomo_yaml_name
    )

    # Check that AreTomo Mode is 0-3
    if (args[&#34;aretomo_mode&#34;] &lt; 0) or (args[&#34;aretomo_mode&#34;] &gt; 2):
        raise ValueError(&#34;AreTomo mode must be 0, 1, 2&#34;)

    # Add optional kwargs TODO: Implement
    # aretomo_params.params[&#39;AreTomo_kwargs&#39;] = kwargs

    if args[&#34;aretomo_mode&#34;] != 1:  # for workflows with alignment
        # Set InMrc
        st_file_list = _find_files_with_ext(
            args[&#34;input_ext&#34;],
            rootname,
            suffix,
            str(args[&#34;input_mrc_folder&#34;])
        )

        if len(st_file_list) == 0:  # assume that input_mrc_folder is from motioncor
            # Create input stacks from motioncor images
            _create_stacks_with_imod(args)
            st_file_list = _find_files_with_ext(
                &#34;.st&#34;,
                rootname,
                suffix,
                str(args[&#34;output_path&#34;])
            )

        aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;input_mrc&#34;] = st_file_list

        # Set AngFile
        if args[&#34;tilt_angles&#34;] == &#34;&#34;:
            tlt_file_list = _find_files_with_ext(
                &#34;.rawtlt&#34;,
                rootname,
                suffix,
                str(args[&#34;input_mrc_folder&#34;])
            )
            if len(tlt_file_list) == 0: # assume that input_mrc_folder is from motioncor
                tlt_file_list = _find_files_with_ext(
                    &#34;.rawtlt&#34;,
                    rootname,
                    suffix,
                    str(args[&#34;output_path&#34;])
                )
        else:
            tlt_file_list = args[&#34;tilt_angles&#34;]

        aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;tilt_angles&#34;] = tlt_file_list

        # Set process list
        ts_list = _get_process_list(
            st_file_list,
            rootname,
            suffix,
            args[&#34;input_ext&#34;]
        )
        aretomo_params.params[&#34;System&#34;][&#34;process_list&#34;] = ts_list

        # Set output mrc
        output_lookup = {0: &#34;_ali.mrc&#34;, 2: &#34;_rec.mrc&#34;}
        # out_file_list = [
        #     (f&#34;{aretomo_params.params[&#39;System&#39;][&#39;output_path&#39;]}/&#34;
        #      f&#34;{os.path.splitext(os.path.basename(file))[0]}/&#34;
        #      f&#34;{os.path.splitext(os.path.basename(file))[0]}&#34;
        #      f&#34;{output_lookup[args[&#39;aretomo_mode&#39;]]}&#34;) for file in st_file_list
        # ]

        rootname = aretomo_params.params[&#39;System&#39;][&#39;output_rootname&#39;]
        suffix = aretomo_params.params[&#39;System&#39;][&#39;output_suffix&#39;]
        ext = output_lookup[args[&#39;aretomo_mode&#39;]]
        out_file_list = [
            (f&#34;{aretomo_params.params[&#39;System&#39;][&#39;output_path&#39;]}/&#34;
             f&#34;{rootname}_{curr_ts:04d}{suffix}/&#34;
             f&#34;{rootname}_{curr_ts:04d}{suffix}{ext}&#34;
            ) for curr_ts in ts_list
        ]

        aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;output_mrc&#34;] = out_file_list

    elif args[&#34;aretomo_mode&#34;] == 1: # for reconstruction only
        # Set InMrc
        st_file_list = _find_files_with_ext(
            &#34;_ali.mrc&#34;,
            rootname,
            suffix,
            str(args[&#34;input_mrc_folder&#34;])
        )
        aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;input_mrc&#34;] = st_file_list

        # Set AngFile
        if args[&#34;tilt_angles&#34;] == &#34;&#34;:
            # NOTE: sometimes if .fid.tlt files are present these are accidentally found too.
            # Temp fix
            # tlt_file_list = _find_files_with_ext(
            #     &#34;.tlt&#34;,
            #     rootname,
            #     suffix,
            #     str(args[&#34;input_mrc_folder&#34;])
            # )
            tlt_file_list = [f&#34;{f.strip(&#39;_ali.mrc&#39;)}.tlt&#34; for f in st_file_list]

            aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;tilt_angles&#34;] = tlt_file_list
        else:
            tlt_file_list = args[&#34;tilt_angles&#34;]
        aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;tilt_angles&#34;] = tlt_file_list

        # Set process list
        ts_list = _get_process_list(st_file_list, rootname, suffix, &#34;_ali.mrc&#34;)
        aretomo_params.params[&#34;System&#34;][&#34;process_list&#34;] = ts_list

        # Set output mrc
        out_file_list = [
            (f&#34;{aretomo_params.params[&#39;System&#39;][&#39;output_path&#39;]}/&#34;
             f&#34;{os.path.splitext(os.path.basename(file))[0].strip(&#39;_ali&#39;)}/&#34;
             f&#34;{os.path.splitext(os.path.basename(file))[0]}&#34;
             f&#34;_rec.mrc&#34;) for file in st_file_list
        ]
        aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;output_mrc&#34;] = out_file_list

    # Add the rest of the argparse values to aretomo_params
    aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;aretomo_mode&#34;] = args[&#34;aretomo_mode&#34;]
    aretomo_params.params[&#34;AreTomo_setup&#34;][&#34;output_binning&#34;] = args[&#34;output_binning&#34;]
    aretomo_params.params[&#34;AreTomo_recon&#34;][&#34;volz&#34;] = args[&#34;volz&#34;]
    aretomo_params.params[&#34;AreTomo_recon&#34;][&#34;sample_thickness&#34;] = args[&#34;sample_thickness&#34;]
    aretomo_params.params[&#34;AreTomo_recon&#34;][&#34;pixel_size&#34;] = args[&#34;pixel_size&#34;]
    aretomo_params.params[&#34;AreTomo_recon&#34;][&#34;recon_algo&#34;] = args[&#34;recon_algo&#34;]

    _update_volz(args, aretomo_params)

    # update and write yaml file
    with open(Path(aretomo_yaml_name), &#34;w&#34;) as f:
        yaml.dump(aretomo_params.params, f, indent=4, sort_keys=False)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Ot2Rec.aretomo.AreTomo"><code class="flex name class">
<span>class <span class="ident">AreTomo</span></span>
<span>(</span><span>project_name, params_in, logger_in)</span>
</code></dt>
<dd>
<div class="desc"><p>Class encapsulating a AreTomo object</p>
<p>Initialising a AreTomo object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>project_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of current project</dd>
<dt><strong><code>params_in</code></strong> :&ensp;<code>Params</code></dt>
<dd>parameters for stack creation</dd>
<dt><strong><code>logger_in</code></strong> :&ensp;<code>Logger</code></dt>
<dd>logger object to keep record of progress and errors</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AreTomo:
    &#34;&#34;&#34;
    Class encapsulating a AreTomo object
    &#34;&#34;&#34;

    def __init__(self,
                 project_name,
                 params_in,
                 logger_in,
                 ):
        &#34;&#34;&#34;
        Initialising a AreTomo object

        Args:
            project_name (str): name of current project
            params_in (Params): parameters for stack creation
            logger_in (Logger): logger object to keep record of progress and errors
        &#34;&#34;&#34;

        self.proj_name = project_name

        self.pObj = params_in
        self.params = self.pObj.params

        self.logObj = logger_in

        self.md_out = {}

        self.sta = {}

        self._get_internal_metadata()

    def _get_internal_metadata(self):
        &#34;&#34;&#34;
        Method to prepare internal metadata for processing and checking
        &#34;&#34;&#34;
        self.basis_folder = self.params[&#39;System&#39;][&#39;output_path&#39;]
        if self.basis_folder.endswith(&#39;/&#39;):
            self.basis_folder = self.basis_folder[:-1]

        self.rootname = self.params[&#39;System&#39;][&#39;output_rootname&#39;]
        if self.rootname.endswith(&#39;_&#39;):
            self.rootname = self.rootname[:-1]

        self.suffix = self.params[&#39;System&#39;][&#39;output_suffix&#39;]
        if self.suffix.endswith(&#39;_&#39;):
            self.suffix = self.suffix[:-1]

        # Create the folders and dictionary for future reference
        self._path_dict = {}
        self.md_out[&#34;process_list&#34;] = dict(zip(range(1, len(self.params[&#39;System&#39;][&#39;process_list&#39;])+1),
                                               self.params[&#39;System&#39;][&#39;process_list&#39;]))
        for curr_ts in self.params[&#39;System&#39;][&#39;process_list&#39;]:
            subfolder = (f&#34;{self.basis_folder}/&#34;
                         f&#34;{self.rootname}_{curr_ts:04d}{self.suffix}&#34;)
            os.makedirs(subfolder, exist_ok=True)
            # self._path_dict[curr_ts] = subfolder
            if &#34;aretomo_output_dir&#34; not in list(self.md_out.keys()):
                self.md_out[&#34;aretomo_output_dir&#34;] = {}
                self.md_out[&#34;aretomo_align_stats&#34;] = {}
            self.md_out[&#34;aretomo_output_dir&#34;][curr_ts] = subfolder
            self.md_out[&#34;aretomo_align_stats&#34;][curr_ts] = (
                f&#34;{subfolder}/&#34;
                f&#34;{self.rootname}_{curr_ts:04d}{self.suffix}.st.aln&#34;
            )

        if self.params[&#34;AreTomo_setup&#34;][&#34;out_imod&#34;] != &#34;N/A&#34;:
            self.sta_folder = f&#34;{self.basis_folder}/STA&#34;
            self.md_out[&#34;aretomo_STA_dir&#34;] = self.sta_folder
            os.makedirs(self.sta_folder, exist_ok=True)

    def _get_aretomo_align_command(self, i):
        &#34;&#34;&#34;
        Method to get command to set up AreTomo align

        Args:
            i (int): The i-th tilt series to process
        &#34;&#34;&#34;
        cmd = [
            &#39;AreTomo&#39;,
            &#39;-InMrc&#39;,
            self.params[&#39;AreTomo_setup&#39;][&#39;input_mrc&#39;][i],
            &#39;-OutMrc&#39;,
            self.params[&#39;AreTomo_setup&#39;][&#39;output_mrc&#39;][i],
            &#39;-AngFile&#39;,
            self.params[&#39;AreTomo_setup&#39;][&#39;tilt_angles&#39;][i],
            &#39;-VolZ&#39;,
            &#39;0&#39;,
            &#39;-OutBin&#39;,
            str(self.params[&#39;AreTomo_setup&#39;][&#39;output_binning&#39;]),
        ]

        # Specify path to AreTomo if not using module loaded version
        if len(self.params[&#39;System&#39;][&#39;aretomo_path&#39;]) &gt; 0:
            cmd[0] = self.params[&#39;System&#39;][&#39;aretomo_path&#39;]

        return cmd

    def _get_aretomo_recon_command(self, i):
        &#34;&#34;&#34;
        Method to get command to set up AreTomo reconstruction

        Args:
            i (int): The i-th tilt series to process
        &#34;&#34;&#34;
        cmd = [
            &#39;AreTomo&#39;,
            &#39;-InMrc&#39;,
            self.params[&#39;AreTomo_setup&#39;][&#39;input_mrc&#39;][i],
            &#39;-OutMrc&#39;,
            self.params[&#39;AreTomo_setup&#39;][&#39;output_mrc&#39;][i],
            &#39;-AngFile&#39;,
            self.params[&#39;AreTomo_setup&#39;][&#39;tilt_angles&#39;][i],
            &#39;-VolZ&#39;,
            str(self.params[&#39;AreTomo_recon&#39;][&#39;volz&#39;]),
            &#39;-OutBin&#39;,
            str(self.params[&#39;AreTomo_setup&#39;][&#39;output_binning&#39;]),
        ]

        if self.params[&#39;AreTomo_setup&#39;][&#39;aretomo_mode&#39;] == 1:
            cmd.append(&#39;-Align&#39;)
            cmd.append(&#39;0&#39;)
        
        if self.params[&#39;AreTomo_recon&#39;][&#39;recon_algo&#39;] == &#34;WBP&#34;:
            # WBP
            cmd.append(&#39;-Wbp&#39;)
            cmd.append(&#39;1&#39;)

        # Specify path to AreTomo if not using module loaded version
        if len(self.params[&#39;System&#39;][&#39;aretomo_path&#39;]) &gt; 0:
            cmd[0] = self.params[&#39;System&#39;][&#39;aretomo_path&#39;]

        return cmd

    def _run_aretomo(self, i):
        &#34;&#34;&#34;
        Method to run AreTomo workflows
        &#34;&#34;&#34;
        curr_ts = self.params[&#39;System&#39;][&#39;process_list&#39;][i]

        # check AreTomo mode
        if self.params[&#39;AreTomo_setup&#39;][&#39;aretomo_mode&#39;] == 0:
            align_cmd = self._get_aretomo_align_command(i)
            cmd = align_cmd
        else:
            recon_cmd = self._get_aretomo_recon_command(i)
            cmd = recon_cmd

        out_imod = self.params[&#39;AreTomo_setup&#39;][&#39;out_imod&#39;]
        if out_imod != &#34;N/A&#34;:
            outimod_lookup = {
                &#34;RELION4&#34;: &#34;1&#34;,
                &#34;Warp&#34;: &#34;2&#34;,
                &#34;Local alignment&#34;: &#34;3&#34;,
            }
            cmd.append(&#39;-OutImod&#39;)
            cmd.append(outimod_lookup[out_imod])
        
        # Add darktol
        if self.params[&#39;AreTomo_setup&#39;][&#39;aretomo_mode&#39;] != 1:
            cmd.append(&#34;-DarkTol&#34;)
            cmd.append(str(self.params[&#39;AreTomo_setup&#39;][&#39;dark_tol&#39;]))

        # Add extra kwargs
        kwargs = self.params[&#34;AreTomo_kwargs&#34;].keys()
        for kwarg in kwargs:
            cmd.append(kwarg)
            cmd.append(self.params[&#34;AreTomo_kwargs&#34;][kwarg])

        # Add AreTomo command and out_mrc to md_out
        if &#34;aretomo_cmd&#34; not in list(self.md_out.keys()):
            self.md_out[&#34;aretomo_cmd&#34;] = {}
        self.md_out[&#34;aretomo_cmd&#34;][curr_ts] = &#34; &#34;.join(cmd)

        # Run aretomo
        aretomo_run = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            encoding=&#39;ascii&#39;,
            check=True,
        )

        # If STA files are generated save folder names to move to common folder
        if self.params[&#34;AreTomo_setup&#34;][&#34;out_imod&#34;] != &#34;N/A&#34;:
            output_mrc = self.params[&#34;AreTomo_setup&#34;][&#34;output_mrc&#34;][i]
            self.sta[curr_ts] = (
                f&#39;{self.basis_folder}/&#39;
                f&#39;{self.rootname}_{curr_ts:04d}{self.suffix}/&#39;
                f&#39;{os.path.splitext(os.path.basename(output_mrc))[0]}_Imod/&#39;
            )

        self.logObj(f&#34;\nStdOut:{aretomo_run.stdout}\n&#34;)
        self.logObj(f&#34;\nStdErr:{aretomo_run.stderr}\n&#34;)

    def run_aretomo_all(self):
        &#34;&#34;&#34;
        Method to run AreTomo for all ts in process list
        &#34;&#34;&#34;
        ts_list = self.params[&#39;System&#39;][&#39;process_list&#39;]
        tqdm_iter = tqdm(ts_list, ncols=100)
        for i, curr_ts in enumerate(tqdm_iter):
            tqdm_iter.set_description(f&#34;Processing TS {curr_ts}...&#34;)
            self._run_aretomo(i)
        self.export_metadata()

    def export_metadata(self):
        &#34;&#34;&#34;
        Method to export metadata as yaml
        &#34;&#34;&#34;
        # If STA files created, move to common folder
        if self.params[&#34;AreTomo_setup&#34;][&#34;out_imod&#34;] != &#34;N/A&#34;: 
            for ts in list(self.sta.keys()):
                sta_ts_folder = (
                    f&#34;{self.sta_folder}/{self.sta[ts].split(os.sep)[-2]}&#34;
                )
                if os.path.exists(sta_ts_folder):
                    self.logObj(
                        f&#34;STA folder {sta_ts_folder} not empty, overwriting.&#34;
                    )
                    shutil.rmtree(sta_ts_folder)
                shutil.move(
                    src=self.sta[ts],
                    dst=self.sta_folder,
                )

        yaml_file = self.proj_name + &#34;_aretomo_mdout.yaml&#34;

        with open(yaml_file, &#39;w&#39;) as f:
            yaml.dump(self.md_out, f, indent=4, sort_keys=False)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Ot2Rec.aretomo.AreTomo.export_metadata"><code class="name flex">
<span>def <span class="ident">export_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to export metadata as yaml</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_metadata(self):
    &#34;&#34;&#34;
    Method to export metadata as yaml
    &#34;&#34;&#34;
    # If STA files created, move to common folder
    if self.params[&#34;AreTomo_setup&#34;][&#34;out_imod&#34;] != &#34;N/A&#34;: 
        for ts in list(self.sta.keys()):
            sta_ts_folder = (
                f&#34;{self.sta_folder}/{self.sta[ts].split(os.sep)[-2]}&#34;
            )
            if os.path.exists(sta_ts_folder):
                self.logObj(
                    f&#34;STA folder {sta_ts_folder} not empty, overwriting.&#34;
                )
                shutil.rmtree(sta_ts_folder)
            shutil.move(
                src=self.sta[ts],
                dst=self.sta_folder,
            )

    yaml_file = self.proj_name + &#34;_aretomo_mdout.yaml&#34;

    with open(yaml_file, &#39;w&#39;) as f:
        yaml.dump(self.md_out, f, indent=4, sort_keys=False)</code></pre>
</details>
</dd>
<dt id="Ot2Rec.aretomo.AreTomo.run_aretomo_all"><code class="name flex">
<span>def <span class="ident">run_aretomo_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to run AreTomo for all ts in process list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_aretomo_all(self):
    &#34;&#34;&#34;
    Method to run AreTomo for all ts in process list
    &#34;&#34;&#34;
    ts_list = self.params[&#39;System&#39;][&#39;process_list&#39;]
    tqdm_iter = tqdm(ts_list, ncols=100)
    for i, curr_ts in enumerate(tqdm_iter):
        tqdm_iter.set_description(f&#34;Processing TS {curr_ts}...&#34;)
        self._run_aretomo(i)
    self.export_metadata()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Ot2Rec" href="index.html">Ot2Rec</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Ot2Rec.aretomo.create_yaml" href="#Ot2Rec.aretomo.create_yaml">create_yaml</a></code></li>
<li><code><a title="Ot2Rec.aretomo.run" href="#Ot2Rec.aretomo.run">run</a></code></li>
<li><code><a title="Ot2Rec.aretomo.update_yaml" href="#Ot2Rec.aretomo.update_yaml">update_yaml</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Ot2Rec.aretomo.AreTomo" href="#Ot2Rec.aretomo.AreTomo">AreTomo</a></code></h4>
<ul class="">
<li><code><a title="Ot2Rec.aretomo.AreTomo.export_metadata" href="#Ot2Rec.aretomo.AreTomo.export_metadata">export_metadata</a></code></li>
<li><code><a title="Ot2Rec.aretomo.AreTomo.run_aretomo_all" href="#Ot2Rec.aretomo.AreTomo.run_aretomo_all">run_aretomo_all</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>